{
    "Math functions": {
        "abs": {
            "signatures": [
                "(numeric)abs(numeric\u00a0x)"
            ],
            "description": "Returns the absolute value of x.\u00a0 If x is integer, the C++ function llabs() is used and an integer vector is returned; if x is float, the C++ function fabs() is used and a float vector is returned."
        },
        "acos": {
            "signatures": [
                "(float)acos(numeric\u00a0x)"
            ],
            "description": "Returns the arc cosine of x using the C++ function acos()."
        },
        "asin": {
            "signatures": [
                "(float)asin(numeric\u00a0x)"
            ],
            "description": "Returns the arc sine of x using the C++ function asin()."
        },
        "atan": {
            "signatures": [
                "(float)atan(numeric\u00a0x)"
            ],
            "description": "Returns the arc tangent of x using the C++ function atan()."
        },
        "atan2": {
            "signatures": [
                "(float)atan2(numeric\u00a0x, numeric\u00a0y)"
            ],
            "description": "Returns the arc tangent of y/x using the C++ function atan2(), which uses the signs of both x and y to determine the correct quadrant for the result."
        },
        "ceil": {
            "signatures": [
                "(float)ceil(float\u00a0x)"
            ],
            "description": "Returns the ceiling of x: the smallest integral value greater than or equal to x.\u00a0 Note that the return value is float even though integral values are guaranteed, because values could be outside of the range representable by integer."
        },
        "cos": {
            "signatures": [
                "(float)cos(numeric\u00a0x)"
            ],
            "description": "Returns the cosine of x using the C++ function cos()."
        },
        "cumProduct": {
            "signatures": [
                "(numeric)cumProduct(numeric\u00a0x)"
            ],
            "description": "Returns the cumulative product of x: a vector of equal length as x, in which the element at index i is equal to the product of the elements of x across the range 0:i.\u00a0 The return type will match the type of x.\u00a0 If x is of type integer, but all of the values of the cumulative product vector cannot be represented in that type, an error condition will result."
        },
        "cumSum": {
            "signatures": [
                "(numeric)cumSum(numeric\u00a0x)"
            ],
            "description": "Returns the cumulative sum of x: a vector of equal length as x, in which the element at index i is equal to the sum of the elements of x across the range 0:i.\u00a0 The return type will match the type of x.\u00a0 If x is of type integer, but all of the values of the cumulative sum vector cannot be represented in that type, an error condition will result."
        },
        "exp": {
            "signatures": [
                "(float)exp(numeric\u00a0x)"
            ],
            "description": "Returns the base-e exponential of x, ex,\u00a0 using the C++ function exp().\u00a0 This may be somewhat faster than E^x for large vectors."
        },
        "floor": {
            "signatures": [
                "(float)floor(float\u00a0x)"
            ],
            "description": "Returns the floor of x: the largest integral value less than or equal to x.\u00a0 Note that the return value is float even though integral values are guaranteed, because values could be outside of the range representable by integer."
        },
        "integerDiv": {
            "signatures": [
                "(integer)integerDiv(integer\u00a0x, integer\u00a0y)"
            ],
            "description": "Returns the result of integer division of x by y.\u00a0 The / operator in Eidos always produces a float result; if you want an integer result you may use this function instead.\u00a0 If any value of y is 0, an error will result.\u00a0 The parameters x and y must either be of equal length, or one of the two must be a singleton.\u00a0 The precise behavior of integer division, in terms of how rounding and negative values are handled, may be platform dependent; it will be whatever the C++ behavior of integer division is on the given platform.\u00a0 Eidos does not guarantee any particular behavior, so use this function with caution."
        },
        "integerMod": {
            "signatures": [
                "(integer)integerMod(integer\u00a0x, integer\u00a0y)"
            ],
            "description": "Returns the result of integer modulo of x by y.\u00a0 The % operator in Eidos always produces a float result; if you want an integer result you may use this function instead.\u00a0 If any value of y is 0, an error will result.\u00a0 The parameters x and y must either be of equal length, or one of the two must be a singleton.\u00a0 The precise behavior of integer modulo, in terms of how rounding and negative values are handled, may be platform dependent; it will be whatever the C++ behavior of integer modulo is on the given platform.\u00a0 Eidos does not guarantee any particular behavior, so use this function with caution."
        },
        "isFinite": {
            "signatures": [
                "(logical)isFinite(float\u00a0x)"
            ],
            "description": "Returns the finiteness of x: T if x is not INF or NAN, F if x is INF or NAN.\u00a0 INF and NAN are defined only for type float, so x is required to be a float.\u00a0 Note that isFinite() is not the opposite of isInfinite(), because NAN is considered to be neither finite nor infinite."
        },
        "isInfinite": {
            "signatures": [
                "(logical)isInfinite(float\u00a0x)"
            ],
            "description": "Returns the infiniteness of x: T if x is INF, F otherwise.\u00a0 INF is defined only for type float, so x is required to be a float.\u00a0 Note that isInfinite() is not the opposite of isFinite(), because NAN is considered to be neither finite nor infinite."
        },
        "isNAN": {
            "signatures": [
                "(logical)isNAN(float\u00a0x)"
            ],
            "description": "Returns the undefinedness of x: T if x is not NAN, F if x is NAN.\u00a0 NAN is defined only for type float, so x is required to be a float."
        },
        "log": {
            "signatures": [
                "(float)log(numeric\u00a0x)"
            ],
            "description": "Returns the base-e logarithm of x using the C++ function log()."
        },
        "log10": {
            "signatures": [
                "(float)log10(numeric\u00a0x)"
            ],
            "description": "Returns the base-10 logarithm of x using the C++ function log10()."
        },
        "log2": {
            "signatures": [
                "(float)log2(numeric\u00a0x)"
            ],
            "description": "Returns the base-2 logarithm of x using the C++ function log2()."
        },
        "product": {
            "signatures": [
                "(numeric$)product(numeric\u00a0x)"
            ],
            "description": "Returns the product of x: the result of multiplying all of the elements of x together.\u00a0 If x is float, the result will be float.\u00a0 If x is integer, things are a bit more complex; the result will be integer if it can fit into the integer type without overflow issues (including during intermediate stages of the computation), otherwise it will be float."
        },
        "round": {
            "signatures": [
                "(float)round(float\u00a0x)"
            ],
            "description": "Returns the round of x: the integral value nearest to x, rounding half-way cases away from 0 (different from the rounding policy of R, which rounds halfway cases toward the nearest even number).\u00a0 Note that the return value is float even though integral values are guaranteed, because values could be outside of the range representable by integer."
        },
        "setDifference": {
            "signatures": [
                "(*)setDifference(*\u00a0x, *\u00a0y)"
            ],
            "description": "Returns the set-theoretic (asymmetric) difference of x and y, denoted x \u2216 y: a vector containing all elements that are in x but are not in y.\u00a0 Duplicate elements will be stripped out, in the same manner as the unique() function.\u00a0 The order of elements in the returned vector is arbitrary and should not be relied upon.\u00a0 The returned vector will be of the same type as x and y, and x and y must be of the same type."
        },
        "setIntersection": {
            "signatures": [
                "(*)setIntersection(*\u00a0x, *\u00a0y)"
            ],
            "description": "Returns the set-theoretic intersection of x and y, denoted x \u2229 y: a vector containing all elements that are in both x and y (but not in only x or y).\u00a0 Duplicate elements will be stripped out, in the same manner as the unique() function.\u00a0 The order of elements in the returned vector is arbitrary and should not be relied upon.\u00a0 The returned vector will be of the same type as x and y, and x and y must be of the same type."
        },
        "setSymmetricDifference": {
            "signatures": [
                "(*)setSymmetricDifference(*\u00a0x, *\u00a0y)"
            ],
            "description": "Returns the set-theoretic symmetric difference of x and y, denoted x \u2206 y: a vector containing all elements that are in x or y, but not in both.\u00a0 Duplicate elements will be stripped out, in the same manner as the unique() function.\u00a0 The order of elements in the returned vector is arbitrary and should not be relied upon.\u00a0 The returned vector will be of the same type as x and y, and x and y must be of the same type."
        },
        "setUnion": {
            "signatures": [
                "(*)setUnion(*\u00a0x, *\u00a0y)"
            ],
            "description": "Returns the set-theoretic union of x and y, denoted x \u222a y: a vector containing all elements that are in x and/or y.\u00a0 Duplicate elements will be stripped out, in the same manner as the unique() function.\u00a0 This function is therefore roughly equivalent to unique(c(x, y)), but this function will probably be faster.\u00a0 The order of elements in the returned vector is arbitrary and should not be relied upon.\u00a0 The returned vector will be of the same type as x and y, and x and y must be of the same type."
        },
        "sign": {
            "signatures": [
                "(numeric)sign(numeric\u00a0x)"
            ],
            "description": "Returns the sign of x, meaning that for each element of x, a value of either -1, 0, or 1 will be returned as the corresponding element in the returned vector depending upon whether the original element was (respectively) negative, zero, or positive.\u00a0 If x is integer, an integer vector is returned; if x is float, a float vector is returned."
        },
        "sin": {
            "signatures": [
                "(float)sin(numeric\u00a0x)"
            ],
            "description": "Returns the sine of x using the C++ function sin()."
        },
        "sqrt": {
            "signatures": [
                "(float)sqrt(numeric\u00a0x)"
            ],
            "description": "Returns the square root of x using the C++ function sqrt().\u00a0 This may be somewhat faster than x^0.5 for large vectors."
        },
        "sum": {
            "signatures": [
                "(numeric$)sum(lif\u00a0x)"
            ],
            "description": "Returns the sum of x: the result of adding all of the elements of x together.\u00a0 The unusual parameter type signature lif indicates that x can be logical, integer, or float.\u00a0 If x is float, the result will be float.\u00a0 If x is logical, the result will be integer (the number of T values in x, since the integer values of T and F are 1 and 0 respectively).\u00a0 If x is integer, things are a bit more complex; in this case, the result will be integer if it can fit into the integer type without overflow issues (including during intermediate stages of the computation), otherwise it will be float.\u00a0 Note that floating-point roundoff issues can cause this function to return inexact results when x is float type; this is rarely an issue, but see the sumExact() function for an alternative."
        },
        "sumExact": {
            "signatures": [
                "(float$)sumExact(float\u00a0x)"
            ],
            "description": "Returns the exact sum of x: the exact result of adding all of the elements of x together.\u00a0 Unlike the sum() function, sumExact() accepts only type float, since the sum() function is already exact for other types.\u00a0 When summing floating-point values \u2013 particularly values that vary across many orders of magnitude \u2013 the precision limits of floating-point numbers can lead to roundoff errors that cause the sum() function to return an inexact result.\u00a0 This function does additional work to ensure that the final result is exact within the possible limits of the float type; some roundoff may still inevitably occur, in other words, but a more exact result could not be represented with a value of type float.\u00a0 The disadvantage of using this function instead of sum() is that it is much slower \u2013 about 35 times slower, according to one test on macOS, but that will vary across operating systems and hardware.\u00a0 This function is rarely truly needed, but apart from the performance consequences there is no disadvantage to using it."
        },
        "tan": {
            "signatures": [
                "(float)tan(numeric\u00a0x)"
            ],
            "description": "Returns the tangent of x using the C++ function tan()."
        },
        "trunc": {
            "signatures": [
                "(float)trunc(float\u00a0x)"
            ],
            "description": "Returns the truncation of x: the integral value nearest to, but no larger in magnitude than, x.\u00a0 Note that the return value is float even though integral values are guaranteed, because values could be outside of the range representable by integer."
        }
    },
    "Statistics functions": {
        "cor": {
            "signatures": [
                "(float)cor(numeric\u00a0x, [Nif\u00a0y\u00a0=\u00a0NULL])"
            ],
            "description": "Returns the sample Pearson\u2019s correlation coefficient between vectors x and y, usually denoted r.\u00a0 If y is NULL, it is considered to have the same value as x; for vector x this is not very useful (since the correlation of x with itself is 1.0 by definition), but it is more useful for calculating a correlation matrix using the columns of x (see below).\u00a0 The sizes of x and y must be identical.\u00a0 If x and y have a size of 0 or 1, NAN will be returned (a change in behavior from Eidos 4.0; it used to return NULL).\u00a0 The return value will be a singleton float. It is also legal to call cor() with matrix x and/or y.\u00a0 In this case the return value will be a correlation matrix between x and y.\u00a0 Each column of x will be represented by one row of the result (or if x is a vector, the result will simply have one row representing x), and each column of y will be represented by one column of the result (or if y is a vector, the result will simply have one column representing y).\u00a0 Each element in the result matrix will therefore represent the correlation between a column of matrix x (or the entirety of vector x) and a column of matrix y (or the entirety of vector y).\u00a0 Calling cor(x, x), or equivalently cor(x), thus produces a symmetric correlation matrix among the columns of x."
        },
        "cov": {
            "signatures": [
                "(float)cov(numeric\u00a0x, [Nif\u00a0y\u00a0=\u00a0NULL])"
            ],
            "description": "Returns the corrected sample covariance between vectors x and y.\u00a0 If y is NULL, it is considered to have the same value as x; for vector x this is equivalent to calling var(x), but it is more useful for calculating a variance-covariance matrix using the columns of x (see below).\u00a0 The sizes of x and y must be identical.\u00a0 If x and y have a size of 0 or 1, NAN will be returned (a change in behavior from Eidos 4.0; it used to return NULL).\u00a0 The return value will be a singleton float. It is also legal to call cov() with matrix x and/or y.\u00a0 In this case the return value will be a covariance matrix between x and y.\u00a0 Each column of x will be represented by one row of the result (or if x is a vector, the result will simply have one row representing x), and each column of y will be represented by one column of the result (or if y is a vector, the result will simply have one column representing y).\u00a0 Each element in the result matrix will therefore represent the covariance between a column of matrix x (or the entirety of vector x) and a column of matrix y (or the entirety of vector y).\u00a0 Calling cov(x, x), or equivalently cov(x), thus produces a symmetric variance-covariance matrix among the columns of x."
        },
        "filter": {
            "signatures": [
                "(float)filter(numeric\u00a0x, float\u00a0filter, [lif$\u00a0outside\u00a0=\u00a0F])"
            ],
            "description": "Returns the result of convolving x with filter.\u00a0 The returned vector will be the same length as x.\u00a0 The convolution is performed by centering filter on each position of x to produce a corresponding result element that is the sum over the products of each filter value with each x value within the filter\u2019s range.\u00a0 The length of filter is required to be odd, so that the filter has a central value (and can thus be centered over each value of x). If the filter, centered over a given value of x, extends beyond the end of x then the calculation of the corresponding element of the result is governed by the outside parameter.\u00a0 When outside is F (the default), the corresponding element in the result will be NAN; this matches the behavior of the R filter() function (except that R uses NA).\u00a0 If outside is T, values outside x will be excluded from the calculation (the filter value covering that position will be considered to be 0), and the other values in the filter will be adjusted so that the sum of the absolute values of the filter weights used is unchanged, to compensate for the excluded values by giving the positions inside x more weight. Finally, if outside is integer or float, that value will be used as the value of x for all positions outside x; one might pass an expected value or mean value in this way, to be used for all outside positions. This function is useful for computing running means and similar transformations of an input vector.\u00a0 For a simple running mean of width w, pass rep(1/w, w) for filter.\u00a0 That case is automatically detected and handled efficiently; otherwise, the runtime of this function is proportional to the length of x times the length of filter, and so will be slow for long filters."
        },
        "max": {
            "signatures": [
                "(+$)max(+\u00a0x, ...)"
            ],
            "description": "Returns the maximum of x and the other arguments supplied: the single greatest value contained by all of them.\u00a0 All of the arguments must be the same type as x, and the return type will match that of x.\u00a0 If all of the arguments have a size of 0, the return value will be NULL; note that this means that max(x,\u00a0max(y)) may produce an error, if max(y) is NULL, in cases where max(x,\u00a0y) does not."
        },
        "mean": {
            "signatures": [
                "(float$)mean(lif\u00a0x)"
            ],
            "description": "Returns the arithmetic mean of x: the sum of x divided by the number of values in x.\u00a0 If x has a size of 0, the return value will be NULL.\u00a0 The unusual parameter type signature lif indicates that x can be logical, integer, or float; if x is logical, it is coerced to integer internally (with F being 0 and T being 1, as always), allowing mean() to calculate the average truth value of a logical vector."
        },
        "min": {
            "signatures": [
                "(+$)min(+\u00a0x, ...)"
            ],
            "description": "Returns the minimum of x and the other arguments supplied: the single smallest value contained by all of them.\u00a0 All of the arguments must be the same type as x, and the return type will match that of x.\u00a0 If all of the arguments have a size of 0, the return value will be NULL; note that this means that min(x,\u00a0min(y)) may produce an error, if min(y) is NULL, in cases where min(x,\u00a0y) does not."
        },
        "pmax": {
            "signatures": [
                "(+)pmax(+\u00a0x, +\u00a0y)"
            ],
            "description": "Returns the parallel maximum of x and y: the element-wise maximum for each corresponding pair of elements in x and y.\u00a0 The type of x and y must match, and the returned value will have the same type.\u00a0 In one usage pattern the size of x and y match, in which case the returned value will have the same size.\u00a0 In the other usage pattern either x and y is a singleton, in which case the returned value will match the size of the non-singleton argument, and pairs of elements for comparison will be formed between the singleton\u2019s element and each of the elements in the non-singleton."
        },
        "pmin": {
            "signatures": [
                "(+)pmin(+\u00a0x, +\u00a0y)"
            ],
            "description": "Returns the parallel minimum of x and y: the element-wise minimum for each corresponding pair of elements in x and y.\u00a0 The type of x and y must match, and the returned value will have the same type.\u00a0 In one usage pattern the size of x and y match, in which case the returned value will have the same size.\u00a0 In the other usage pattern either x and y is a singleton, in which case the returned value will match the size of the non-singleton argument, and pairs of elements for comparison will be formed between the singleton\u2019s element and each of the elements in the non-singleton."
        },
        "quantile": {
            "signatures": [
                "(float)quantile(numeric\u00a0x, [Nf\u00a0probs\u00a0=\u00a0NULL])"
            ],
            "description": "Returns sample quantiles of x for the given probabilities.\u00a0 The smallest value in x corresponds to a probability of 0, and the largest value in x to a probability of 1.\u00a0 The probs vector should be a vector of probabilities in [0, 1], or NULL, which is equivalent to c(0.0, 0.25, 0.5, 0.75, 1.0), requesting sample quartiles. The quantile function linearly interpolates between the points of the empirical cumulative distribution function.\u00a0 In other words, if x is a vector of length n+1, then the quantiles with probs equal to (0, 1/n, 2/n, ..., (n\u22121)/n, 1) are equal to the sorted values of x, and the quantile is a linear function of probs otherwise.\u00a0 Note that there are many ways to compute quantiles; this algorithm corresponds to R\u2019s default \u201ctype 7\u201d algorithm."
        },
        "range": {
            "signatures": [
                "(numeric)range(numeric\u00a0x, ...)"
            ],
            "description": "Returns the range of x and the other arguments supplied: a vector of length 2 composed of the minimum and maximum values contained by all of them, at indices 0 and 1 respectively.\u00a0 All of the arguments must be the same type as x, and the return type will match that of x.\u00a0 If all of the arguments have a size of 0, the return value will be NULL; note that this means that range(x,\u00a0range(y)) may produce an error, if range(y) is NULL, in cases where range(x,\u00a0y) does not."
        },
        "rank": {
            "signatures": [
                "(numeric)rank(numeric\u00a0x, [string$\u00a0tiesMethod\u00a0=\u00a0\"average\"])"
            ],
            "description": "Returns the ranks of the elements of x: a vector of length L (the length of x), composed of the relative ranks, from 1 to L, of each corresponding element of x.\u00a0 The tiesMethod parameter may be any of \"average\" (the default), \"first\", \"last\", \"max\", or \"min\" (\"random\", supported by R, is not supported by Eidos at this time but could be added if needed).\u00a0 For \"average\", the return value is of type float; for all others, it is of type integer.\u00a0 (Note that the return type does not depend upon the type of x.) The result for all of these tiesMethod values is identical (except for type) if the elements of x are unique; the difference between these methods is in how ties are resolved.\u00a0 Suppose that n elements of x are tied (because they are equal), corresponding to ranks k through k+n\u22121.\u00a0 For tiesMethod \"average\", all n tied elements receive the same rank, (k + (n\u22121)/2), which is the average of the ranks.\u00a0 For \"first\", the first tied element receives rank k, upward to the last tied element receiving rank k+n\u22121.\u00a0 For \"last\", the last tied element receives rank k, downward to the first tied element receiving rank k+n\u22121.\u00a0 For \"max\", all n tied element receive the maximum rank, k+n\u22121.\u00a0 For \"min\", all n tied element receive the minimum rank, k."
        },
        "sd": {
            "signatures": [
                "(float$)sd(numeric\u00a0x)"
            ],
            "description": "Returns the corrected sample standard deviation of x.\u00a0 If x has a size of 0 or 1, NAN will be returned (a change in behavior from Eidos 4.0; it used to return NULL).\u00a0 Matrix/array dimensions are ignored by sd(); it simply uses all of the elements of x for its calculation."
        },
        "ttest": {
            "signatures": [
                "(float$)ttest(float\u00a0x, [Nf\u00a0y\u00a0=\u00a0NULL], [Nf$\u00a0mu\u00a0=\u00a0NULL])"
            ],
            "description": "Returns the p-value resulting from running a t-test with the supplied data.\u00a0 Two types of t-tests can be performed.\u00a0 If x and y are supplied (i.e., y is non-NULL), a two-sample unpaired two-sided Welch\u2019s t-test is conducted using the samples in x and y, each of which must contain at least two elements.\u00a0 The null hypothesis for this test is that the two samples are drawn from populations with the same mean.\u00a0 Other options, such as pooled-variance t-tests, paired t-tests, and one-sided t-tests, are not presently available.\u00a0 If x and mu are supplied (i.e., mu is non-NULL), a one-sample t-test is conducted in which the null hypothesis is that the sample is drawn from a population with mean mu. Note that the results from this function are substantially different from those produced by R.\u00a0 The Eidos ttest() function uses uncorrected sample statistics, which means they will be biased for small sample sizes, whereas R probably uses corrected, unbiased sample statistics.\u00a0 This is an Eidos bug, and might be fixed if anyone complains.\u00a0 If large sample sizes are used, however, the bias is likely to be small, and uncorrected statistics are simpler and faster to compute."
        },
        "var": {
            "signatures": [
                "(float$)var(numeric\u00a0x)"
            ],
            "description": "Returns the corrected sample variance of x.\u00a0 If x has a size of 0 or 1, NAN will be returned (a change in behavior from Eidos 4.0; it used to return NULL).\u00a0 This is the square of the standard deviation calculated by sd().\u00a0 It is illegal to call var() with a matrix or array argument; use cov() to calculate a variance-covariance matrix."
        }
    },
    "Distribution drawing and density functions": {
        "dmvnorm": {
            "signatures": [
                "(float)dmvnorm(float\u00a0x, numeric\u00a0mu, numeric\u00a0sigma)"
            ],
            "description": "Returns a vector of probability densities for a k-dimensional multivariate normal distribution with a length k mean vector mu and a k \u00d7 k variance-covariance matrix sigma.\u00a0 The mu and sigma parameters are used for all densities.\u00a0 The quantile values, x, should be supplied as a matrix with one row per vector of quantile values and k columns (one column per dimension); for convenience, a single quantile may be supplied as a vector rather than a matrix with just one row.\u00a0 The number of dimensions k must be at least two; for k=1, use dnorm(). Cholesky decomposition of the variance-covariance matrix sigma is involved as an internal step, and this requires that sigma be positive-definite; if it is not, an error will result.\u00a0 When more than one density is needed, it is much more efficient to call dmvnorm() once to generate all of the densities, since the Cholesky decomposition of sigma can then be done just once."
        },
        "dbeta": {
            "signatures": [
                "(float)dbeta(float\u00a0x, numeric\u00a0alpha, numeric\u00a0beta)"
            ],
            "description": "Returns a vector of probability densities for a beta distribution at quantiles x with parameters alpha and beta.\u00a0 The alpha and beta parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of the same length as x, specifying a value for each density computation.\u00a0 The probability density function is P(s\u00a0|\u00a0\u03b1,\u03b2)\u00a0= [\u0393(\u03b1+\u03b2)/\u0393(\u03b1)\u0393(\u03b2)]s\u03b1\u22121(1\u2212s)\u03b2\u22121, where \u03b1 is alpha and \u03b2 is beta.\u00a0 Both parameters must be greater than 0."
        },
        "dexp": {
            "signatures": [
                "(float)dexp(float\u00a0x, [numeric\u00a0mu\u00a0=\u00a01])"
            ],
            "description": "Returns a vector of probability densities for an exponential distribution at quantiles x with mean mu (i.e. rate 1/mu).\u00a0 The mu parameter may either be a singleton, specifying a single value to be used for all of the draws, or they may be vectors of the same length as x, specifying a value for each density computation."
        },
        "dgamma": {
            "signatures": [
                "(float)dgamma(float\u00a0x, numeric\u00a0mean, numeric\u00a0shape)"
            ],
            "description": "Returns a vector of probability densities for a gamma distribution at quantiles x with mean mean and shape parameter shape.\u00a0 The mean and shape parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of the same length as x, specifying a value for each density computation.\u00a0 The probability density function is P(s\u00a0|\u00a0\u03b1,\u03b2)\u00a0= [\u0393(\u03b1)\u03b2\u03b1]\u22121s\u03b1\u22121exp(\u2212s/\u03b2), where \u03b1 is the shape parameter shape, and the mean of the distribution given by mean is equal to \u03b1\u03b2."
        },
        "dnorm": {
            "signatures": [
                "(float)dnorm(float\u00a0x, [numeric\u00a0mean\u00a0=\u00a00], [numeric\u00a0sd\u00a0=\u00a01])"
            ],
            "description": "Returns a vector of probability densities for a normal distribution at quantiles x with mean mean and standard deviation sd.\u00a0 The mean and sd parameters may either be singletons, specifying a single value to be used for all of the densities, or they may be vectors of the same length as x, specifying a value for each density computation."
        },
        "findInterval": {
            "signatures": [
                "(integer)findInterval(numeric\u00a0x, numeric\u00a0vec, [logical$\u00a0rightmostClosed\u00a0=\u00a0F], [logical$\u00a0allInside\u00a0=\u00a0F])"
            ],
            "description": "Returns a vector of interval indices for the values in x within a vector of non-decreasing breakpoints vec.\u00a0 The returned integer vector contains, for each corresponding element of x, the index of the interval in vec within which that element of x is contained. More precisely, if i is the returned integer vector from findInterval(x, v), and N is length(v), then for each index j in x, it will be true that v[i[j]] \u2264 x[j] < v[i[j]+1], treating v[-1] as -INF and v[N] as INF, assuming that the two flags rightmostClosed and allInside have their default value of F.\u00a0 The effects of the flags will be discussed below.\u00a0 Note that vec must be non-decreasing; in other words, it must be sorted in ascending order, although it may have duplicate values.\u00a0 The returned vector will thus be equal in length to x, and each of its elements will be in the interval [-1, N-1]. The rightmostClosed flag, if T, alters the above behavior to treat the rightmost interval, vec[N-2] .. vec[N-1], as closed.\u00a0 This means that if x[j]==vec[N-1] (i.e., equals max(vec)), the corresponding result i[j] will be N-2 as for all other values in the last interval. The allInside flag, if T, alters the above behavior to coerce returned indices into 0 .. N-2.\u00a0 In other words, -1 is mapped to 0, and N-1 is mapped to N-2."
        },
        "pnorm": {
            "signatures": [
                "(float)pnorm(float\u00a0q, [numeric\u00a0mean\u00a0=\u00a00], [numeric\u00a0sd\u00a0=\u00a01])"
            ],
            "description": "Returns a vector of cumulative distribution function values for a normal distribution at quantiles q with mean mean and standard deviation sd.\u00a0 The mean and sd parameters may either be singletons, specifying a single value to be used for all of the quantiles, or they may be vectors of the same length as q, specifying a value for each quantile."
        },
        "qnorm": {
            "signatures": [
                "(float)qnorm(float\u00a0p, [numeric\u00a0mean\u00a0=\u00a00], [numeric\u00a0sd\u00a0=\u00a01])"
            ],
            "description": "Returns a vector of quantiles for a normal distribution with lower tail probabilities less than p, with mean mean and standard deviation sd. The mean and sd parameters may either be singletons, specifying a single value to be used for all of the quantiles, or they may be vectors of the same length as p, specifying a value for each quantile computation."
        },
        "rbeta": {
            "signatures": [
                "(float)rbeta(integer$\u00a0n, numeric\u00a0alpha, numeric\u00a0beta)"
            ],
            "description": "Returns a vector of n random draws from a beta distribution with parameters alpha and beta.\u00a0 The alpha and beta parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length n, specifying a value for each draw.\u00a0 Draws are made from a beta distribution with probability density P(s\u00a0|\u00a0\u03b1,\u03b2)\u00a0= [\u0393(\u03b1+\u03b2)/\u0393(\u03b1)\u0393(\u03b2)]s\u03b1\u22121(1\u2212s)\u03b2\u22121, where \u03b1 is alpha and \u03b2 is beta.\u00a0 Both parameters must be greater than 0.\u00a0 The values drawn are in the interval [0, 1]."
        },
        "rbinom": {
            "signatures": [
                "(integer)rbinom(integer$\u00a0n, integer\u00a0size, float\u00a0prob)"
            ],
            "description": "Returns a vector of n random draws from a binomial distribution with a number of trials specified by size and a probability of success specified by prob.\u00a0 The size and prob parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length n, specifying a value for each draw."
        },
        "rcauchy": {
            "signatures": [
                "(float)rcauchy(integer$\u00a0n, [numeric\u00a0location\u00a0=\u00a00], [numeric\u00a0scale\u00a0=\u00a01])"
            ],
            "description": "Returns a vector of n random draws from a Cauchy distribution with location location and scale scale.\u00a0 The location and scale parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length n, specifying a value for each draw."
        },
        "rdunif": {
            "signatures": [
                "(integer)rdunif(integer$\u00a0n, [integer\u00a0min\u00a0=\u00a00], [integer\u00a0max\u00a0=\u00a01])"
            ],
            "description": "Returns a vector of n random draws from a discrete uniform distribution from min to max, inclusive.\u00a0 The min and max parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length n, specifying a value for each draw.\u00a0 See runif() for draws from a continuous uniform distribution."
        },
        "rexp": {
            "signatures": [
                "(float)rexp(integer$\u00a0n, [numeric\u00a0mu\u00a0=\u00a01])"
            ],
            "description": "Returns a vector of n random draws from an exponential distribution with mean mu (i.e. rate 1/mu).\u00a0 The mu parameter may either be a singleton, specifying a single value to be used for all of the draws, or it may be a vector of length n, specifying a value for each draw."
        },
        "rf": {
            "signatures": [
                "(float)rf(integer$\u00a0n, numeric\u00a0d1, numeric\u00a0d2)"
            ],
            "description": "Returns a vector of n random draws from an F-distribution with degrees of freedom d1 and d2.\u00a0 The d1 and d2 parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length n, specifying a value for each draw."
        },
        "rgamma": {
            "signatures": [
                "(float)rgamma(integer$\u00a0n, numeric\u00a0mean, numeric\u00a0shape)"
            ],
            "description": "Returns a vector of n random draws from a gamma distribution with mean mean and shape parameter shape.\u00a0 The mean and shape parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length n, specifying a value for each draw.\u00a0 Draws are made from a gamma distribution with probability density P(s\u00a0|\u00a0\u03b1,\u03b2)\u00a0= [\u0393(\u03b1)\u03b2\u03b1]\u22121exp(\u2212s/\u03b2), where \u03b1 is the shape parameter shape, and the mean of the distribution given by mean is equal to \u03b1\u03b2.\u00a0 Values of mean less than zero are allowed, and are equivalent (in principle) to the negation of a draw from a gamma distribution with the same shape parameter and the negation of the mean parameter."
        },
        "rgeom": {
            "signatures": [
                "(integer)rgeom(integer$\u00a0n, float\u00a0p)"
            ],
            "description": "Returns a vector of n random draws from a geometric distribution with parameter p.\u00a0 The p parameter may either be a singleton, specifying a single value to be used for all of the draws, or it may be a vector of length n, specifying a value for each draw.\u00a0 Eidos follows R in using the geometric distribution with support on the set {0, 1, 2, \u2026}, where the drawn value indicates the number of failures prior to success.\u00a0 There is an alternative definition, based upon the number of trial required to get one success, so beware."
        },
        "rlnorm": {
            "signatures": [
                "(float)rlnorm(integer$\u00a0n, [numeric\u00a0meanlog\u00a0=\u00a00], [numeric\u00a0sdlog\u00a0=\u00a01])"
            ],
            "description": "Returns a vector of n random draws from a lognormal distribution with mean meanlog and standard deviation sdlog, specified on the log scale.\u00a0 The meanlog and sdlog parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length n, specifying a value for each draw."
        },
        "rmvnorm": {
            "signatures": [
                "(float)rmvnorm(integer$\u00a0n, numeric\u00a0mu, numeric\u00a0sigma)"
            ],
            "description": "Returns a matrix of n random draws from a k-dimensional multivariate normal distribution with a length k mean vector mu and a k \u00d7 k variance-covariance matrix sigma.\u00a0 The mu and sigma parameters are used for all n draws.\u00a0 The draws are returned as a matrix with n rows (one row per draw) and k columns (one column per dimension).\u00a0 The number of dimensions k must be at least two; for k=1, use rnorm(). Cholesky decomposition of the variance-covariance matrix sigma is involved as an internal step, and this requires that sigma be positive-definite; if it is not, an error will result.\u00a0 When more than one draw is needed, it is much more efficient to call rmvnorm() once to generate all of the draws, since the Cholesky decomposition of sigma can then be done just once."
        },
        "rnbinom": {
            "signatures": [
                "(integer)rnbinom(integer$\u00a0n, numeric\u00a0size, float\u00a0prob)"
            ],
            "description": "Returns a vector of n random draws from a negative binomial distribution representing the number of failures which occur in a sequence of Bernoulli trials before reaching a target number of successful trials specified by size, given a probability of success specified by prob.\u00a0 The mean of this distribution for size s and prob p is s(1\u2212p)/p, with variance s(1\u2212p)/p2.\u00a0 The size and prob parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length n, specifying a value for each draw."
        },
        "rnorm": {
            "signatures": [
                "(float)rnorm(integer$\u00a0n, [numeric\u00a0mean\u00a0=\u00a00], [numeric\u00a0sd\u00a0=\u00a01])"
            ],
            "description": "Returns a vector of n random draws from a normal distribution with mean mean and standard deviation sd.\u00a0 The mean and sd parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length n, specifying a value for each draw."
        },
        "rpois": {
            "signatures": [
                "(integer)rpois(integer$\u00a0n, numeric\u00a0lambda)"
            ],
            "description": "Returns a vector of n random draws from a Poisson distribution with parameter lambda (not to be confused with the language concept of a \u201clambda\u201d; lambda here is just the name of a parameter, because the symbol typically used for the parameter of a Poisson distribution is the Greek letter \u03bb).\u00a0 The lambda parameter may either be a singleton, specifying a single value to be used for all of the draws, or it may be a vector of length n, specifying a value for each draw."
        },
        "runif": {
            "signatures": [
                "(float)runif(integer$\u00a0n, [numeric\u00a0min\u00a0=\u00a00], [numeric\u00a0max\u00a0=\u00a01])"
            ],
            "description": "Returns a vector of n random draws from a continuous uniform distribution from min to max, inclusive.\u00a0 The min and max parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length n, specifying a value for each draw.\u00a0 See rdunif() for draws from a discrete uniform distribution."
        },
        "rweibull": {
            "signatures": [
                "(float)rweibull(integer$\u00a0n, numeric\u00a0lambda, numeric\u00a0k)"
            ],
            "description": "Returns a vector of n random draws from a Weibull distribution with scale parameter lambda and shape parameter k, both greater than zero.\u00a0 The lambda and k parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length n, specifying a value for each draw.\u00a0 Draws are made from a Weibull distribution with probability distribution P(s\u00a0|\u00a0\u03bb,k)\u00a0=\u00a0(k / \u03bbk)\u00a0sk\u22121\u00a0exp(-(s/\u03bb)k)."
        },
        "rztpois": {
            "signatures": [
                "(integer)rztpois(integer$\u00a0n, numeric\u00a0lambda)"
            ],
            "description": "Returns a vector of n random draws from a zero-truncated Poisson distribution with parameter lambda (not to be confused with the language concept of a \u201clambda\u201d; lambda here is just the name of a parameter, because the symbol typically used for the parameter of a Poisson distribution is the Greek letter \u03bb).\u00a0 The zero-truncated Poisson distribution is the conditional probability distribution of a Poisson-distributed random variable, given that the value of the random variable is not zero.\u00a0 The values returned by rztpois() will therefore never be zero. The lambda parameter, \u03bb, may either be a singleton, specifying a single value to be used for all of the draws, or it may be a vector of length n, specifying a value for each draw.\u00a0 It is important to note that for rpois() the expected mean of the distribution is \u03bb, but for rztpois() the expected mean of the distribution is \u03bb\u00a0/\u00a0(1\u00a0\u2212\u00a0exp(\u2212\u03bb)), precisely because the zero-truncated Poisson distribution is conditional upon being non-zero."
        }
    },
    "Vector construction functions": {
        "c": {
            "signatures": [
                "(*)c(...)"
            ],
            "description": "Returns the concatenation of all of its parameters into a single vector, stripped of all matrix/array dimensions (see rbind() and cbind() for concatenation that does not strip this information).\u00a0 The parameters will be promoted to the highest type represented among them, and that type will be the return type.\u00a0 NULL values are ignored; they have no effect on the result."
        },
        "float": {
            "signatures": [
                "(float)float(integer$\u00a0length)"
            ],
            "description": "Returns a new float vector of the length specified by length, filled with 0.0 values.\u00a0 This can be useful for pre-allocating a vector which you then fill with values by subscripting."
        },
        "integer": {
            "signatures": [
                "(integer)integer(integer$\u00a0length, [integer$\u00a0fill1\u00a0=\u00a00], [integer$\u00a0fill2\u00a0=\u00a01], [Ni\u00a0fill2Indices\u00a0=\u00a0NULL])"
            ],
            "description": "Returns a new integer vector of the length specified by length, filled with 0 values by default.\u00a0 This can be useful for pre-allocating a vector which you then fill with values by subscripting. If a value is supplied for fill1, the new vector will be filled with that value instead of the default of 0.\u00a0 Additionally, if a non-NULL vector is supplied for fill2Indices, the indices specified by fill2Indices will be filled with the value provided by fill2.\u00a0 For example, given the default values of 0 and 1 for fill1 and fill2, the returned vector will contain 1 at all positions specified by fill2Indices, and will contain 0 at all other positions."
        },
        "logical": {
            "signatures": [
                "(logical)logical(integer$\u00a0length)"
            ],
            "description": "Returns a new logical vector of the length specified by length, filled with F values.\u00a0 This can be useful for pre-allocating a vector which you then fill with values by subscripting."
        },
        "object": {
            "signatures": [
                "(object<Object>)object(void)"
            ],
            "description": "Returns a new empty object vector.\u00a0 Unlike float(), integer(), logical(), and string(), a length cannot be specified and the new vector contains no elements.\u00a0 This is because there is no default value for the object type.\u00a0 Adding to such a vector is typically done with c().\u00a0 Note that the return value is of type object<Object>; this method creates an object vector that does not know what element type it contains.\u00a0 Such object vectors may be mixed freely with other object vectors in c() and similar contexts; the result of such mixing will take its object-element type from the object vector with a defined object-element type (if any)."
        },
        "rep": {
            "signatures": [
                "(*)rep(*\u00a0x, integer$\u00a0count)"
            ],
            "description": "Returns the repetition of x: the entirety of x is repeated count times.\u00a0 The return type matches the type of x."
        },
        "repEach": {
            "signatures": [
                "(*)repEach(*\u00a0x, integer\u00a0count)"
            ],
            "description": "Returns the repetition of elements of x: each element of x is repeated.\u00a0 If count is a singleton, it specifies the number of times that each element of x will be repeated.\u00a0 Otherwise, the length of count must be equal to the length of x; in this case, each element of x is repeated a number of times specified by the corresponding value of count."
        },
        "sample": {
            "signatures": [
                "(*)sample(*\u00a0x, integer$\u00a0size, [logical$\u00a0replace\u00a0=\u00a0F], [Nif\u00a0weights\u00a0=\u00a0NULL])"
            ],
            "description": "Returns a vector of size containing a sample from the elements of x.\u00a0 If replace is T, sampling is conducted with replacement (the same element may be drawn more than once); if it is F (the default), then sampling is done without replacement.\u00a0 A vector of weights may be supplied in the optional parameter weights; if not NULL, it must be equal in size to x, all weights must be non-negative, and the sum of the weights must be greater than 0.\u00a0 If weights is NULL (the default), then equal weights are used for all elements of x.\u00a0 An error occurs if sample() runs out of viable elements from which to draw; most notably, if sampling is done without replacement then size must be at most equal to the size of x, but if weights of zero are supplied then the restriction on size will be even more stringent.\u00a0 The draws are obtained from the standard Eidos random number generator, which might be shared with the Context."
        },
        "seq": {
            "signatures": [
                "(numeric)seq(numeric$\u00a0from, numeric$\u00a0to, [Nif$\u00a0by\u00a0=\u00a0NULL], [Ni$\u00a0length\u00a0=\u00a0NULL])"
            ],
            "description": "Returns a sequence, starting at from and proceeding in the direction of to until the next value in the sequence would fall beyond to.\u00a0 If the optional parameters by and length are both NULL (the default), the sequence steps by values of 1 or -1 (as needed to proceed in the direction of to).\u00a0 A different step value may be supplied with by, but must have the necessary sign.\u00a0 Alternatively, a sequence length may be supplied in length, in which case the step magnitude will be chosen to produce a sequence of the requested length (with the necessary sign, as before).\u00a0 If from and to are both integer then the return type will be integer when possible (but this may not be possible, depending upon values supplied for by or length), otherwise it will be float."
        },
        "seqAlong": {
            "signatures": [
                "(integer)seqAlong(*\u00a0x)"
            ],
            "description": "Returns an index sequence along x, from 0 to size(x) - 1, with a step of 1.\u00a0 This is a convenience function for easily obtaining a set of indices to address or iterate through a vector.\u00a0 Any matrix/array dimension information is ignored; the index sequence is suitable for indexing into x as a vector."
        },
        "seqLen": {
            "signatures": [
                "(integer)seqLen(integer$\u00a0length)"
            ],
            "description": "Returns an index sequence of length, from 0 to length - 1, with a step of 1; if length is 0 the sequence will be zero-length.\u00a0 This is a convenience function for easily obtaining a set of indices to address or iterate through a vector.\u00a0 Note that when length is 0, using the sequence operator with 0:(length-1) will produce 0\u00a0-1, and calling seq(a,\u00a0b,\u00a0length=length) will raise an error, but seqLen(length) will return integer(0), making seqLen() particularly useful for generating a sequence of a given length that might be zero."
        },
        "string": {
            "signatures": [
                "(string)string(integer$\u00a0length)"
            ],
            "description": "Returns a new string vector of the length specified by length, filled with \"\" values.\u00a0 This can be useful for pre-allocating a vector which you then fill with values by subscripting."
        }
    },
    "Value inspection & manipulation functions": {
        "all": {
            "signatures": [
                "(logical$)all(logical\u00a0x, ...)"
            ],
            "description": "Returns T if all values are T in x and in any other arguments supplied; if any value is F, returns F.\u00a0 All arguments must be of logical type.\u00a0 If all arguments are zero-length, T is returned."
        },
        "any": {
            "signatures": [
                "(logical$)any(logical\u00a0x, ...)"
            ],
            "description": "Returns T if any value is T in x or in any other arguments supplied; if all values are F, returns F.\u00a0 All arguments must be of logical type.\u00a0 If all arguments are zero-length, F is returned."
        },
        "cat": {
            "signatures": [
                "(void)cat(*\u00a0x, [string$\u00a0sep\u00a0=\u00a0\" \"], [logical$\u00a0error\u00a0=\u00a0F])"
            ],
            "description": "Concatenates output to Eidos\u2019s output stream, joined together by sep.\u00a0 The value x that is output may be of any type.\u00a0 A newline is not appended to the output, unlike the behavior of print(); if a trailing newline is desired, you can use \"\\n\" (or use the catn() function).\u00a0 Also unlike print(), cat() tends to emit very literal output; print(logical(0)) will emit \u201clogical(0)\u201d, for example \u2013 showing a semantic interpretation of the value \u2013 whereas cat(logical(0)) will emit nothing at all, since there are no elements in the value (it is zero-length).\u00a0 Similarly, print(NULL) will emit \u201cNULL\u201d, but cat(NULL) will emit nothing. By default (when error is F), the output is sent to the standard Eidos output stream.\u00a0 When running at the command line, this sends it to stdout; when running in SLiMgui, this sends it to the simulation window\u2019s output textview.\u00a0 If error is T, the output is instead sent to the Eidos error stream.\u00a0 When running at the command line, this sends it to stderr; when running in SLiMgui, the output is routed to the simulation\u2019s debugging output window."
        },
        "catn": {
            "signatures": [
                "(void)catn([*\u00a0x\u00a0=\u00a0\"\"], [string$\u00a0sep\u00a0=\u00a0\" \"], [logical$\u00a0error\u00a0=\u00a0F])"
            ],
            "description": "Concatenates output (with a trailing newline) to Eidos\u2019s output stream, joined together by sep.\u00a0 The behavior of catn() is identical to that of cat(), except that a final newline character is appended to the output for convenience.\u00a0 For catn() a default value of \"\" is supplied for x, to allow a simple catn() call with no parameters to emit a newline. By default (when error is F), the output is sent to the standard Eidos output stream.\u00a0 When running at the command line, this sends it to stdout; when running in SLiMgui, this sends it to the simulation window\u2019s output textview.\u00a0 If error is T, the output is instead sent to the Eidos error stream.\u00a0 When running at the command line, this sends it to stderr; when running in SLiMgui, the output is routed to the simulation\u2019s debugging output window."
        },
        "format": {
            "signatures": [
                "(string)format(string$\u00a0format, numeric\u00a0x)"
            ],
            "description": "Returns a vector of formatted strings generated from x, based upon the formatting string format.\u00a0 The format parameter may be any string value, but must contain exactly one escape sequence beginning with the % character.\u00a0 This escape sequence specifies how to format a single value from the vector x.\u00a0 The returned vector contains one string value for each element of x; each string value is identical to the string supplied in format, except with a formatted version of the corresponding value from x substituted in place of the escape sequence. The syntax for format is a subset of the standard C/C++ printf()-style format strings (e.g., http://en.cppreference.com/w/c/io/fprintf).\u00a0 The escape sequence used to format each value of x is composed of several elements: Note that relative to the standard C/C++ printf()-style behavior, there are a few differences: (1) only a single escape sequence may be present in the format string, (2) the use of * to defer field width and precision values to a passed parameter is not supported, (3) only integer and float values of x are supported, (4) only the %d, %i, %o, %x, %X, %f, %F, %e, %E, %g, and %G format specifiers are supported, and (5) no length modifiers may be supplied, since Eidos does not support different sizes of the integer and float types.\u00a0 Note also that the Eidos conventions of emitting INF and NAN for infinities and Not-A-Number values respectively is not honored by this function; the strings generated for such values are platform-dependent, following the implementation definition of the C++ compiler used to build Eidos, since format() calls through to snprintf() to assemble the final string values. For example, format(\"A number: %+7.2f\", c(-4.1, 15.375, 8)) will produce a vector with three elements: \"A number: \u00a0 -4.10\" \"A number:\u00a0 +15.38\" \"A number: \u00a0 +8.00\".\u00a0 The precision of .2 results in two digits after the decimal point, the minimum field width of 7 results in padding of the values on the left (with spaces) to a minimum of seven characters, the flag + causes a sign to be shown on positive values as well as negative values, and the format specifier f leads to the float values of x being formatted in base-10 decimal.\u00a0 One string value is produced in the result vector for each value in the parameter x.\u00a0 These values could then be merged into a single string with paste(), for example, or printed with print() or cat()."
        },
        "identical": {
            "signatures": [
                "(logical$)identical(*\u00a0x, *\u00a0y)"
            ],
            "description": "Returns a logical value indicating whether two values are identical.\u00a0 If x and y have exactly the same type and size, and all of their corresponding elements are exactly the same, and (for matrices and arrays) their dimensions are identical, this will return T, otherwise it will return F.\u00a0 The test here is for exact equality; an integer value of 1 is not considered identical to a float value of 1.0, for example.\u00a0 Elements in object values must be literally the same element, not simply identical in all of their properties.\u00a0 Type promotion is never done.\u00a0 For testing whether two values are the same, this is generally preferable to the use of operator\u00a0== or operator\u00a0!=.\u00a0 Note that identical(NULL,NULL) is T."
        },
        "ifelse": {
            "signatures": [
                "(*)ifelse(logical\u00a0test, *\u00a0trueValues, *\u00a0falseValues)"
            ],
            "description": "Returns the result of a vector conditional operation: a vector composed of values from trueValues, for indices where test is T, and values from falseValues, for indices where test is F.\u00a0 The lengths of trueValues and falseValues must either be equal to 1 or to the length of test; however, trueValues and falseValues don\u2019t need to be the same length as each other.\u00a0 Furthermore, the type of trueValues and falseValues must be the same (including, if they are object type, their element type).\u00a0 The return will be of the same length as test, and of the same type as trueValues and falseValues.\u00a0 Each element of the return vector will be taken from the corresponding element of trueValues if the corresponding element of test is T, or from the corresponding element of falseValues if the corresponding element of test is F; if the vector from which the value is to be taken (i.e., trueValues or falseValues) has a length of 1, that single value is used repeatedly, recycling the vector.\u00a0 If test, trueValues, and/or falseValues are matrices or arrays, that will be ignored by ifelse() except that the result will be of the same dimensionality as test. This is quite similar to a function in R of the same name; note, however, that Eidos evaluates all arguments to functions calls immediately, so trueValues and falseValues will be evaluated fully regardless of the values in test, unlike in R.\u00a0 Value expressions without side effects are therefore recommended."
        },
        "length": {
            "signatures": [
                "(integer$)length(*\u00a0x)"
            ],
            "description": "Returns the size (e.g., length) of x: the number of elements contained in x.\u00a0 Note that length() is a synonym for size()."
        },
        "match": {
            "signatures": [
                "(integer)match(*\u00a0x, *\u00a0table)"
            ],
            "description": "Returns a vector of the positions of (first) matches of x in table.\u00a0 Type promotion is not performed; x and table must be of the same type.\u00a0 For each element of x, the corresponding element in the result will give the position of the first match for that element of x in table; if the element has no match in table, the element in the result vector will be -1.\u00a0 The result is therefore a vector of the same length as x.\u00a0 If a logical result is desired, with T indicating that a match was found for the corresponding element of x, use (match(x, table) >= 0)."
        },
        "order": {
            "signatures": [
                "(integer)order(+\u00a0x, [logical$\u00a0ascending\u00a0=\u00a0T])"
            ],
            "description": "Returns a vector of sorting indices for x: a new integer vector of the same length as x, containing the indices into x that would sort x.\u00a0 In other words, x[order(x)]==sort(x).\u00a0 This can be useful for more complex sorting problems, such as sorting several vectors in parallel by a sort order determined by one of the vectors.\u00a0 If the optional logical parameter ascending is T (the default), then the sorted order will be ascending; if it is F, the sorted order will be descending.\u00a0 The ordering is determined according to the same logic as the < and > operators in Eidos.\u00a0 To easily sort vectors in a single step, use sort() or sortBy(), for non-object and object vectors respectively."
        },
        "paste": {
            "signatures": [
                "(string$)paste(..., [string$\u00a0sep\u00a0=\u00a0\" \"])"
            ],
            "description": "Returns a joined string composed from the string representations of the elements of the parameters passed in, taken in order, joined together by sep.\u00a0 Although this function is based upon the R paste() function of the same name, note that it is much simpler and less powerful; in particular, the result is always a singleton string, rather than returning a non-singleton string vector when one of the parameters is a non-singleton.\u00a0 The string representation used by paste() is the same as that emitted by cat()."
        },
        "paste0": {
            "signatures": [
                "(string$)paste0(...)"
            ],
            "description": "Returns a joined string composed from the string representations of the elements of the parameters passed in, taken in order, joined together with no separator.\u00a0 This function is identical to paste(), except that no separator is used.\u00a0 Note that this differs from the semantics of paste0() in R."
        },
        "print": {
            "signatures": [
                "(void)print(*\u00a0x, [logical$\u00a0error\u00a0=\u00a0F])"
            ],
            "description": "Prints output to Eidos\u2019s output stream.\u00a0 The value x that is output may be of any type.\u00a0 A newline is appended to the output.\u00a0 See cat() for a discussion of the differences between print() and cat(). By default (when error is F), the output is sent to the standard Eidos output stream.\u00a0 When running at the command line, this sends it to stdout; when running in SLiMgui, this sends it to the simulation window\u2019s output textview.\u00a0 If error is T, the output is instead sent to the Eidos error stream.\u00a0 When running at the command line, this sends it to stderr; when running in SLiMgui, the output is routed to the simulation\u2019s debugging output window."
        },
        "rev": {
            "signatures": [
                "(*)rev(*\u00a0x)"
            ],
            "description": "Returns the reverse of x: a new vector with the same elements as x, but in the opposite order."
        },
        "size": {
            "signatures": [
                "(integer$)size(*\u00a0x)"
            ],
            "description": "Returns the size of x: the number of elements contained in x.\u00a0 Note that length() is a synonym for size()."
        },
        "sort": {
            "signatures": [
                "(+)sort(+\u00a0x, [logical$\u00a0ascending\u00a0=\u00a0T])"
            ],
            "description": "Returns a sorted copy of x: a new vector with the same elements as x, but in sorted order.\u00a0 If the optional logical parameter ascending is T (the default), then the sorted order will be ascending; if it is F, the sorted order will be descending.\u00a0 The ordering is determined according to the same logic as the < and > operators in Eidos.\u00a0 To sort an object vector, use sortBy().\u00a0 To obtain indices for sorting, use order()."
        },
        "sortBy": {
            "signatures": [
                "(object)sortBy(object\u00a0x, string$\u00a0property, [logical$\u00a0ascending\u00a0=\u00a0T])"
            ],
            "description": "Returns a sorted copy of x: a new vector with the same elements as x, but in sorted order.\u00a0 If the optional logical parameter ascending is T (the default), then the sorted order will be ascending; if it is F, the sorted order will be descending.\u00a0 The ordering is determined according to the same logic as the < and > operators in Eidos.\u00a0 The property argument gives the name of the property within the elements of x according to which sorting should be done.\u00a0 This must be a simple property name; it cannot be a property path.\u00a0 For example, to sort a Mutation vector by the selection coefficients of the mutations, you would simply pass \"selectionCoeff\", including the quotes, for property.\u00a0 To sort a non-object vector, use sort().\u00a0 To obtain indices for sorting, use order()."
        },
        "str": {
            "signatures": [
                "(void)str(*\u00a0x, [logical$\u00a0error\u00a0=\u00a0F])"
            ],
            "description": "Prints the structure of x: a summary of its type and the values it contains.\u00a0 If x is an object, note that str() produces different results from the str() method of x; the str() function prints the external structure of x (the fact that it is an object, and the number and type of its elements), whereas the str() method prints the internal structure of x (the external structure of all the properties contained by x). By default (when error is F), the output is sent to the standard Eidos output stream.\u00a0 When running at the command line, this sends it to stdout; when running in SLiMgui, this sends it to the simulation window\u2019s output textview.\u00a0 If error is T, the output is instead sent to the Eidos error stream.\u00a0 When running at the command line, this sends it to stderr; when running in SLiMgui, the output is routed to the simulation\u2019s debugging output window."
        },
        "tabulate": {
            "signatures": [
                "(integer)tabulate(integer\u00a0bin, [Ni$\u00a0maxbin\u00a0=\u00a0NULL])"
            ],
            "description": "Returns occurrence counts for each non-negative integer in bin.\u00a0 Occurrence counts are tabulated into bins for each value 0:maxbin in bin; values outside that range are ignored.\u00a0 The default value of maxbin, NULL, is equivalent to passing maxbin=max(0, bin); in other words, by default the result vector will be exactly large enough to accommodate counts for every integer in bin.\u00a0 In any case, the result vector will contain maxbin+1 elements (some or all of which might be zero, if the occurrence count of that integer in bin is zero). Note that the semantics of this function differ slightly from the tabulate() function in R, because R is 1-based and Eidos is 0-based."
        },
        "unique": {
            "signatures": [
                "(*)unique(*\u00a0x, [logical$\u00a0preserveOrder\u00a0=\u00a0T])"
            ],
            "description": "Returns the unique values in x.\u00a0 In other words, for each value k in x that occurs at least once, the vector returned will contain k exactly once.\u00a0 If preserveOrder is T (the default), the order of values in x is preserved, taking the first instance of each value; this is relatively slow, with O(n^2) performance.\u00a0 If preserveOrder if F instead, the order of values in x is not preserved, and no particular ordering should be relied upon; this is relatively fast, with O(n log n) performance.\u00a0 This performance difference will only matter for large vectors, however; for most applications the default behavior can be retained whether the order of the result matters or not."
        },
        "which": {
            "signatures": [
                "(integer)which(logical\u00a0x)"
            ],
            "description": "Returns the indices of T values in x.\u00a0 In other words, if an index k in x is T, then the vector returned will contain k; if index k in x is F, the vector returned will omit k.\u00a0 One way to look at this is that it converts from a logical subsetting vector to an integer (index-based) subsetting vector, without changing which subset positions would be selected."
        },
        "whichMax": {
            "signatures": [
                "(integer$)whichMax(+\u00a0x)"
            ],
            "description": "Returns the index of the (first) maximum value in x.\u00a0 In other words, if k is equal to the maximum value in x, then the vector returned will contain the index of the first occurrence of k in x.\u00a0 If the maximum value is unique, the result is the same as (but more efficient than) the expression which(x==max(x)), which returns the indices of all of the occurrences of the maximum value in x."
        },
        "whichMin": {
            "signatures": [
                "(integer$)whichMin(+\u00a0x)"
            ],
            "description": "Returns the index of the (first) minimum value in x.\u00a0 In other words, if k is equal to the minimum value in x, then the vector returned will contain the index of the first occurrence of k in x.\u00a0 If the minimum value is unique, the result is the same as (but more efficient than) the expression which(x==min(x)), which returns the indices of all of the occurrences of the minimum value in x."
        }
    },
    "Value type testing and coercion functions": {
        "asFloat": {
            "signatures": [
                "(float)asFloat(+\u00a0x)"
            ],
            "description": "Returns the conversion to float of x.\u00a0 If x is string and cannot be converted to float, Eidos will throw an error."
        },
        "asInteger": {
            "signatures": [
                "(integer)asInteger(+\u00a0x)"
            ],
            "description": "Returns the conversion to integer of x.\u00a0 If x is of type string or float and cannot be converted to integer, Eidos will throw an error."
        },
        "asLogical": {
            "signatures": [
                "(logical)asLogical(+\u00a0x)"
            ],
            "description": "Returns the conversion to logical of x.\u00a0 Recall that in Eidos the empty string \"\" is considered F, and all other string values are considered T.\u00a0 Converting INF or -INF to logical yields T (since those values are not equal to zero); converting NAN to logical throws an error."
        },
        "asString": {
            "signatures": [
                "(string)asString(+\u00a0x)"
            ],
            "description": "Returns the conversion to string of x.\u00a0 Note that asString(NULL) returns \"NULL\" even though NULL is zero-length."
        },
        "elementType": {
            "signatures": [
                "(string$)elementType(*\u00a0x)"
            ],
            "description": "Returns the element type of x, as a string.\u00a0 For the non-object types, the element type is the same as the type: \"NULL\", \"logical\", \"integer\", \"float\", or \"string\".\u00a0 For object type, however, elementType() returns the name of the type of element contained by the object, such as \"Species\" or \"Mutation\" in the Context of SLiM.\u00a0 Contrast this with type()."
        },
        "isFloat": {
            "signatures": [
                "(logical$)isFloat(*\u00a0x)"
            ],
            "description": "Returns T if x is float type, F otherwise."
        },
        "isInteger": {
            "signatures": [
                "(logical$)isInteger(*\u00a0x)"
            ],
            "description": "Returns T if x is integer type, F otherwise."
        },
        "isLogical": {
            "signatures": [
                "(logical$)isLogical(*\u00a0x)"
            ],
            "description": "Returns T if x is logical type, F otherwise."
        },
        "isNULL": {
            "signatures": [
                "(logical$)isNULL(*\u00a0x)"
            ],
            "description": "Returns T if x is NULL type, F otherwise."
        },
        "isObject": {
            "signatures": [
                "(logical$)isObject(*\u00a0x)"
            ],
            "description": "Returns T if x is object type, F otherwise."
        },
        "isString": {
            "signatures": [
                "(logical$)isString(*\u00a0x)"
            ],
            "description": "Returns T if x is string type, F otherwise."
        },
        "type": {
            "signatures": [
                "(string$)type(*\u00a0x)"
            ],
            "description": ""
        }
    },
    "String manipulation functions": {
        "grep": {
            "signatures": [
                "(lis)grep(string$\u00a0pattern, string\u00a0x, [logical$\u00a0ignoreCase\u00a0=\u00a0F], [string$\u00a0grammar\u00a0=\u00a0\"ECMAScript\"], [string$\u00a0value\u00a0=\u00a0\"indices\"], [logical$\u00a0fixed\u00a0=\u00a0F], [logical$\u00a0invert\u00a0=\u00a0F])"
            ],
            "description": "Searches for regular expression matches in the string-elements of x.\u00a0 Regular expressions (regexes) express patterns that strings can either match or not match; they are very widely used in programming languages and terminal shells.\u00a0 The topic of regexes is very complex, and a great deal of information about them can be found online, including examples and tutorials; this manual will not attempt to document the topic in detail. The grep() function uses a regex supplied in pattern, looking for matches for the regex in each element of x.\u00a0 If ignoreCase is F (the default), the pattern matching will be case sensitive (i.e., uppercase versus lowercase will matter); if it is T, the pattern matching will be case-insensitive. The grammar parameter determines the regex grammar used to find matches.\u00a0 Several options are available.\u00a0 The default, \"ECMAScript\", is a straightforward regex grammar, the specification for which can be found at https://www.cplusplus.com/reference/regex/ECMAScript/ among many other links.\u00a0 The \"basic\" grammar uses POSIX basic regular expressions, often called BRE; this is documented at https://en.wikibooks.org/wiki/Regular_Expressions/POSIX_Basic_Regular_Expressions.\u00a0 The \"extended\" grammar uses POSIX extended regular expressions, often called ERE; this is documented at https://en.wikibooks.org/wiki/Regular_Expressions/POSIX-Extended_Regular_Expressions.\u00a0 The \"awk\" grammar is based upon the \"extended\" grammar, with more escapes for non-printing characters.\u00a0 The \"grep\" and \"egrep\" grammars are based upon the \"basic\" and \"extended\" grammars, respectively, but also allow newline characters (\"\\n\") to separate alternations.\u00a0 If you are not sure which grammar you want to use, \"ECMAScript\" is recommended.\u00a0 All of these grammars are implemented internally in Eidos using the C++ <regex> library, so if you need clarification on the details of a grammar, you can search for related C++ materials online. Information about the matches found is returned in one of four ways.\u00a0 If value is \"indices\" (the default), an integer vector is returned containing the index in x for each match.\u00a0 If value is \"elements\", a string vector is returned containing the actual string-elements of x for each match.\u00a0 If value is \"matches\", a string vector is returned containing only the substring that matched, within each string-element in x that matched (if more than one substring in a given element matched, the first match is returned).\u00a0 Finally, if value is \"logical\" a logical vector is returned, of the same length as x, containing T where the corresponding element of x matched, or F where it did not match.\u00a0 This function therefore encapsulates the functionality of both the grep() and grepl() functions of R; use value=\"logical\" for functionality like that of R\u2019s grepl(). If fixed is F (the default), matching is determined using pattern following the specified regex grammar as described above.\u00a0 If fixed is T, matching is instead determined using pattern as a string value to be matched \u201cas is\u201d, rather than as a regular expression; the grammar specified does not matter in this case, but ignoreCase still applies.\u00a0 This could be thought of as another grammar value, really, meaning \u201cno grammar\u201d, but it is supplied as a separate flag following R. Finally, if invert if F (the default) matching proceeds as normal for the chosen regex grammar, whereas if invert if T matching is inverted: indices, elements, or logical values are returned for the elements of x that did not match.\u00a0 If invert is T, the value parameter may not be \"matches\". Note that there is not presently any way to extract subpattern matches, nor is there any way to perform replacements of matches."
        },
        "nchar": {
            "signatures": [
                "(integer)nchar(string\u00a0x)"
            ],
            "description": "Returns a vector of the number of characters in the string-elements of x."
        },
        "strcontains": {
            "signatures": [
                "(logical)strcontains(string\u00a0x, string$\u00a0s, [integer$\u00a0pos\u00a0=\u00a00])"
            ],
            "description": "Returns the occurrence of a string specified by s in each of the elements of x, starting at position pos.\u00a0 Position 0, the default, is the beginning of x; a position of 0 means the entire string is searched.\u00a0 A starting search position that is at or beyond the end of a given element of x is not an error; it just implies that a match will not be found in that element.\u00a0 The existences of matches are returned as a logical vector; if a match was found in a given element, the corresponding value in the returned vector is T, otherwise it is F.\u00a0 This function is a simplified version of strfind(), which returns the positions of matches.\u00a0 The strprefix() and strsuffix() functions are also related."
        },
        "strfind": {
            "signatures": [
                "(integer)strfind(string\u00a0x, string$\u00a0s, [integer$\u00a0pos\u00a0=\u00a00])"
            ],
            "description": "Returns the first occurrence of a string specified by s in each of the elements of x, starting at position pos.\u00a0 Position 0, the default, is the beginning of x; a position of 0 means the entire string is searched.\u00a0 A starting search position that is at or beyond the end of a given element of x is not an error; it just implies that a match will not be found in that element.\u00a0 The positions of matches are returned as an integer vector; if no match was found in a given element, the corresponding value in the returned vector is -1.\u00a0 The strcontains() function may be used when a logical value (found / not found) is desired."
        },
        "strprefix": {
            "signatures": [
                "(logical)strprefix(string\u00a0x, string$\u00a0s)"
            ],
            "description": "Returns the occurrence of a prefix string specified by s at the beginning of each of the elements of x.\u00a0 The existences of prefixes are returned as a logical vector; if a given element begins with the prefix, the corresponding value in the returned vector is T, otherwise it is F."
        },
        "strsplit": {
            "signatures": [
                "(string)strsplit(string$\u00a0x, [string$\u00a0sep\u00a0=\u00a0\" \"])"
            ],
            "description": "Returns substrings of x that were separated by the separator string sep.\u00a0 Every substring defined by an occurrence of the separator is included, and thus zero-length substrings may be returned.\u00a0 For example, strsplit(\".foo..bar.\", \".\") returns a string vector containing \"\", \"foo\", \"\", \"bar\", \"\".\u00a0 In that example, the empty string between \"foo\" and \"bar\" in the returned vector is present because there were two periods between foo and bar in the input string \u2013 the empty string is the substring between those two separators.\u00a0 If sep is \"\", a vector of single characters will be returned, resulting from splitting x at every position.\u00a0 Note that paste() performs the inverse operation of strsplit()."
        },
        "strsuffix": {
            "signatures": [
                "(logical)strsuffix(string\u00a0x, string$\u00a0s)"
            ],
            "description": "Returns the occurrence of a suffix string specified by s at the end of each of the elements of x.\u00a0 The existences of suffixes are returned as a logical vector; if a given element ends with the suffix, the corresponding value in the returned vector is T, otherwise it is F."
        },
        "substr": {
            "signatures": [
                "(string)substr(string\u00a0x, integer\u00a0first, [Ni\u00a0last\u00a0=\u00a0NULL])"
            ],
            "description": "Returns substrings extracted from the elements of x, spanning character position first to character position last (inclusive).\u00a0 Character positions are numbered from 0 to nchar(x)-1.\u00a0 Positions that fall outside of that range are legal; a substring range that encompasses no characters will produce an empty string.\u00a0 If first is greater than last, an empty string will also result.\u00a0 If last is NULL (the default), then the substring will extend to the end of the string.\u00a0 The parameters first and last may either be singletons, specifying a single value to be used for all of the substrings, or they may be vectors of the same length as x, specifying a value for each substring."
        }
    },
    "Matrix and array functions": {
        "apply": {
            "signatures": [
                "(*)apply(*\u00a0x, integer\u00a0margin, string$\u00a0lambdaSource)"
            ],
            "description": "Applies a block of Eidos code to margins of x.\u00a0 This function is essentially an extension of sapply() for use with matrices and arrays; it is recommended that you fully understand sapply() before tackling this function.\u00a0 As with sapply(), the lambda specified by lambdaSource will be executed for subsets of x, and the results will be concatenated together with type-promotion in the style of c() to produce a result.\u00a0 Unlike sapply(), however, the subsets of x used might be rows, columns, or higher-dimensional slices of x, rather than just single elements, depending upon the value of margin.\u00a0 For apply(), x must be a matrix or array.\u00a0 The apply() function in Eidos is patterned directly after the apply() function in R, and should behave identically, except that dimension indices in Eidos are zero-based whereas in R they are one-based. The margin parameter gives the indices of dimensions of x that will be iterated over when assembling values to supply to lambdaSource.\u00a0 If x is a matrix it has two dimensions: rows, of dimension index 0, and columns, of dimension index 1.\u00a0 These are the indices of the dimension sizes returned by dim(); dim(x)[0] gives the number of rows of x, and dim(x)[1] gives the number of columns.\u00a0 These dimension indices are also apparent when subsetting x; a subset index in position 0, such as x[m,], gives row m of x, whereas a subset index in position 1, such as x[,n], gives column n of x.\u00a0 In the same manner, supplying 0 for margin specifies that subsets of x from x[0,] to x[m,] should be \u201cpassed\u201d to lambdaSource, through the applyValue \u201cparameter\u201d; dimension 0 is iterated over, whereas dimension 1 is taken in aggregate since it is not included in margin.\u00a0 The final effect of this is that whole rows of x are passed to lambdaSource through applyValue.\u00a0 Similarly, margin=1 would specify that subsets of x from x[,0] to x[,n] should be passed to lambdaSource, resulting in whole columns being passed.\u00a0 Specifying margin=c(0,1) would indicate that dimensions 0 and 1 should both be iterated over (dimension 0 more rapidly), so for a matrix each each individual value of x would be passed to lambdaSource.\u00a0 Specifying margin=c(1,0) would similarly iterate over both dimensions, but dimension 1 more rapidly; the traversal order would therefore be different, and the dimensionality of the result would also differ (see below).\u00a0 For higher-dimensional arrays dimension indices beyond 1 exist, and so margin=c(0,1) or margin=c(1,0) would provide slices of x to lambdaSource, each slice having a specific row and column index.\u00a0 Slices are generated by subsetting in the same way as operator [], but additionally, redundant dimensions are dropped as by drop(). The return value from apply() is built up from the type-promoted concatenated results, as if by the c() function, from the iterated execution of lambdaSource; the only question is what dimensional structure is imposed upon that vector of values.\u00a0 If the results from lambdaSource are not of a consistent length, or are of length zero, then the concatenated results are returned as a plain vector.\u00a0 If all results are of length n > 1, the return value is an array of dimensions c(n, dim(x)[margin]); in other words, each n-vector provides the lowest dimension of the result, and the sizes of the marginal dimensions are imposed upon the data above that.\u00a0 If all results are of length n == 1, then if a single margin was specified the result is a vector (of length equal to the size of that marginal dimension), or if more than one margin was specified the result is an array of dimension dim(x)[margin]; in other words, the sizes of the marginal dimensions are imposed upon the data.\u00a0 Since apply() iterates over the marginal dimensions in the same manner, these structures follows the structure of the data. The above explanation may not be entirely clear, so let\u2019s look at an example.\u00a0 If x is a matrix with two rows and three columns, such as defined by x = matrix(1:6, nrow=2);, then executing apply(x,\u00a00,\u00a0\"sum(applyValue);\"); would cause each row of x to be supplied to the lambda through applyValue, and the values in each row would thus be summed to produce 9 12 as a result.\u00a0 The call apply(x,\u00a01,\u00a0\"sum(applyValue);\"); would instead sum columns of x, producing 3 7 11 as a result.\u00a0 Now consider using range() rather than sum() in the lambda, thus producing two values for each row or column.\u00a0 The call apply(x,\u00a00,\u00a0\"range(applyValue);\"); produces a result of matrix(c(1,5,2,6), nrow=2), with the range of the first row of x, 1\u20135, in the first column of the result, and the range of the second row of x, 2\u20136, in the second column.\u00a0 Although visualization becomes more difficult, these same patterns extend to higher dimensions and arbitrary margins of x. For efficiently obtaining the sums of the rows or columns of a matrix, see rowSums() and colSums()."
        },
        "array": {
            "signatures": [
                "(*)array(*\u00a0data, integer\u00a0dim)"
            ],
            "description": "Creates a new array from the data specified by data, with the dimension sizes specified by dim.\u00a0 The first dimension size in dim is the number of rows, and the second is the number of columns; further entries specify the sizes of higher-order dimensions.\u00a0 As many dimensions may be specified as desired, but with a minimum of two dimensions.\u00a0 An array with two dimensions is a matrix (by definition); note that matrix() may provide a more convenient way to make a new matrix.\u00a0 Each dimension must be of size 1 or greater; 0-size dimensions are not allowed. The elements of data are used to populate the new array; the size of data must therefore be equal to the size of the new array, which is the product of all the values in dim.\u00a0 The new array will be filled in dimension order: one element in each row until a column is filled, then on to the next column in the same manner until all columns are filled, and then onward into the higher-order dimensions in the same manner."
        },
        "asVector": {
            "signatures": [
                "(*)asVector(*\u00a0x)"
            ],
            "description": "Creates a new vector from the elements of x, stripping off any dimensional information associated with x being a vector or array.\u00a0 The values of the resulting vector are read out from x in dimension order: one element from each row until a column is completed, then on to the next column in the same manner until all columns are completed, and then onward into the higher-order dimensions in the same manner.\u00a0 If x is already a vector, it is returned unmodified.\u00a0 See drop() for a similar method that drops only matrix/array dimensions that are redundant."
        },
        "cbind": {
            "signatures": [
                "(*)cbind(...)"
            ],
            "description": "Combines vectors or matrices by column to produce a single matrix.\u00a0 The parameters must be vectors (which are interpreted by cbind() as if they were one-column matrices) or matrices.\u00a0 They must be of the same type, of the same class if they are of type object, and have the same number of rows.\u00a0 If these conditions are met, the result is a single matrix with the parameters joined together, left to right.\u00a0 Parameters may instead be NULL, in which case they are ignored; or if all parameters are NULL, the result is NULL.\u00a0 A sequence of vectors, matrices, and NULLs may thus be concatenated with the NULL values removed, analogous to c().\u00a0 Calling cbind(x) is an easy way to create a one-column matrix from a vector. To combine vectors or matrices by row instead, see rbind()."
        },
        "colSums": {
            "signatures": [
                "(numeric)colSums(lif\u00a0x)"
            ],
            "description": "Returns the sums of the columns of x, which must be a matrix.\u00a0 The result is a vector of elements, each providing the sum of the corresponding column of x.\u00a0 If x is of type logical or integer the result will be of type integer; unlike the sum() function, colSums() does not promote the return type to float if integer overflow occurs, but instead throws an error.\u00a0 If x is of type float the result will be of type float.\u00a0 Except for the change in the treatment of integer overflow noted above, this is equivalent to using apply() with sum() to sum the columns of x, but is much faster."
        },
        "det": {
            "signatures": [
                "(numeric$)det(numeric\u00a0x)"
            ],
            "description": "Returns the determinant of x, which must be a square matrix (otherwise an error is raised).\u00a0 The determinant is a scalar-valued function of the entries of the matrix, and characterizes some properties of the matrix.\u00a0 In particular, the determinant is nonzero if and only if the matrix is invertible.\u00a0 If the determinant is zero, the matrix does not have an inverse and is referred to as \u201csingular\u201d.\u00a0 In Eidos the determinant is calculated from the LU decomposition of the matrix.\u00a0 The return type will match the type of x."
        },
        "diag": {
            "signatures": [
                "(*)diag([*\u00a0x\u00a0=\u00a01], [Ni$\u00a0nrow\u00a0=\u00a0NULL], [Ni$\u00a0ncol\u00a0=\u00a0NULL])"
            ],
            "description": "Returns the diagonal of x.\u00a0 This function has four distinct usage patterns (matching R).\u00a0 First, if x is a matrix of any type, it returns the diagonal elements of x as a vector; in this case, nrow and ncol must be NULL.\u00a0 Second, if x is 1 (the default) and nrow is non-NULL, it returns an identity matrix with the requested number of rows (and, if ncol is also non-NULL, the requested number of columns, otherwise the matrix will be square).\u00a0 Third, if x is a singleton integer value and nrow and ncol are NULL, it returns a square identity matrix of size x.\u00a0 Fourth, if x is a logical, integer, or float vector of length at least 2, it returns a matrix that uses the values of x as its diagonal (without recycling or truncation, unlike R) and has F, 0, or 0.0 off-diagonal entries as appropriate. Note that using diag(x), without nrow or ncol, can have unexpected effects if x is a vector that could be of length one.\u00a0 Use diag(x, nrow=length(x)) for consistent behavior."
        },
        "dim": {
            "signatures": [
                "(integer)dim(*\u00a0x)"
            ],
            "description": "Returns the dimensions of matrix or array x.\u00a0 The first dimension value is the number of rows, the second is the number of columns, and further values indicate the sizes of higher-order dimensions, identically to how dimensions are supplied to array().\u00a0 NULL is returned if x is not a matrix or array."
        },
        "drop": {
            "signatures": [
                "(*)drop(*\u00a0x)"
            ],
            "description": "Returns the result of dropping redundant dimensions from matrix or array x.\u00a0 Redundant dimensions are those with a size of exactly 1.\u00a0 Non-redundant dimensions are retained.\u00a0 If only one non-redundant dimension is present, the result is a vector; if more than one non-redundant dimension is present, the result will be a matrix or array.\u00a0 If x is not a matrix or array, it is returned unmodified.\u00a0 See asVector() for a way to drop all dimensions of a matrix or array, whether redundant or not."
        },
        "inverse": {
            "signatures": [
                "(float)inverse(numeric\u00a0x)"
            ],
            "description": "Returns the (multiplicative) inverse of x, which must be a square non-singular matrix (otherwise an error is raised).\u00a0 If matrix B is the inverse of n-by-n matrix A, then AB = BA = In, where In denotes the n-by-n identity matrix and the multiplication used is ordinary matrix multiplication as performed by matrixMult().\u00a0 If x might be singular (and thus non-invertible), and you wish to avoid the possibility of an error, you can call det() first to find the determinant of the matrix; if the determinant is zero, the matrix is singular and does not have an inverse, and so inverse() should not be called.\u00a0 In Eidos the inverse is calculated from the LU decomposition of the matrix."
        },
        "lowerTri": {
            "signatures": [
                "(logical)lowerTri(*\u00a0x, [logical$\u00a0diag\u00a0=\u00a0F])"
            ],
            "description": "Returns the lower triangle of x, which must be a matrix.\u00a0 The return value will be a logical matrix of the same dimensions as x, with elements T in the lower triangle, F elsewhere.\u00a0 If diag is F (the default), the diagonal is not included in the lower triangle; if diag is T, the diagonal is included in the lower triangle (i.e., its elements will be T)."
        },
        "matrix": {
            "signatures": [
                "(*)matrix(*\u00a0data, [Ni$\u00a0nrow\u00a0=\u00a0NULL], [Ni$\u00a0ncol\u00a0=\u00a0NULL], [logical$\u00a0byrow\u00a0=\u00a0F])"
            ],
            "description": "Creates a new matrix from the data specified by data.\u00a0 By default this creates a one-column matrix.\u00a0 If non-NULL values are supplied for nrow and/or ncol, a matrix will be made with the requested number of rows and/or columns if possible; if the length of data is not compatible with the requested dimensions, an error will result.\u00a0 By default, values from data will populate the matrix by columns, filling each column sequentially before moving on to the next column; if byrow is T the matrix will be populated by rows instead."
        },
        "matrixMult": {
            "signatures": [
                "(numeric)matrixMult(numeric\u00a0x, numeric\u00a0y)"
            ],
            "description": "Returns the result of matrix multiplication of x with y.\u00a0 In Eidos (as in R), with two matrices A and B the simple product A\u00a0*\u00a0B multiplies the corresponding elements of the matrices; in other words, if X is the result of A\u00a0*\u00a0B, then Xij\u00a0=\u00a0Aij\u00a0* Bij.\u00a0 This is parallel to the definition of other operators; A\u00a0+\u00a0B adds the corresponding elements of the matrices (Xij\u00a0=\u00a0Aij\u00a0+\u00a0Bij), etc.\u00a0 In R, true matrix multiplication is achieved with a special operator, %*%; in Eidos, the matrixMult() function is used instead. Both x and y must be matrices, and must be conformable according to the standard definition of matrix multiplication (i.e., if x is an n\u00a0\u00d7\u00a0m matrix then y must be a m\u00a0\u00d7\u00a0p matrix, and the result will be a n\u00a0\u00d7\u00a0p matrix).\u00a0 Vectors will not be promoted to matrices by this function, even if such promotion would lead to a conformable matrix."
        },
        "matrixPow": {
            "signatures": [
                "(numeric)matrixPow(numeric\u00a0x, integer$\u00a0power)"
            ],
            "description": "Returns the result of raising matrix x to an integer power.\u00a0 The parameter x must be a square matrix (or an error will be raised).\u00a0 This operation is performed by repeated matrix multiplication with matrixMult(), and uses inverse() to compute the inverse of the matrix if power is negative."
        },
        "nrow": {
            "signatures": [
                "(integer$)nrow(*\u00a0x)"
            ],
            "description": "Returns the number of rows in matrix or array x.\u00a0 For vector x, nrow() returns NULL; size() should be used.\u00a0 An equivalent of R\u2019s NROW() function, which treats vectors as 1-column matrices, is not provided but would be trivial to implement as a user-defined function."
        },
        "ncol": {
            "signatures": [
                "(integer$)ncol(*\u00a0x)"
            ],
            "description": "Returns the number of columns in matrix or array x.\u00a0 For vector x, ncol() returns NULL; size() should be used.\u00a0 An equivalent of R\u2019s NCOL() function, which treats vectors as 1-column matrices, is not provided but would be trivial to implement as a user-defined function."
        },
        "outerProduct": {
            "signatures": [
                "(numeric)outerProduct(numeric\u00a0x, numeric\u00a0y)"
            ],
            "description": "Returns the outer product of vectors x and y.\u00a0 The outer product, x \u2297 y, is the result of matrix multiplication of x with the transpose of y, or xyT.\u00a0 It will be a matrix with a number of rows equal to the length of x, and a number of columns equal to the length of y.\u00a0 It is required that x and y be vectors, not matrices or arrays, that they have non-zero lengths, and that they be the same type \u2013 both integer or both float.\u00a0 The return value will be of the same type as x and y."
        },
        "rbind": {
            "signatures": [
                "(*)rbind(...)"
            ],
            "description": "Combines vectors or matrices by row to produce a single matrix.\u00a0 The parameters must be vectors (which are interpreted by rbind() as if they were one-row matrices) or matrices.\u00a0 They must be of the same type, of the same class if they are of type object, and have the same number of columns.\u00a0 If these conditions are met, the result is a single matrix with the parameters joined together, top to bottom.\u00a0 Parameters may instead be NULL, in which case they are ignored; or if all parameters are NULL, the result is NULL.\u00a0 A sequence of vectors, matrices, and NULLs may thus be concatenated with the NULL values removed, analogous to c().\u00a0 Calling rbind(x) is an easy way to create a one-row matrix from a vector. To combine vectors or matrices by column instead, see cbind()."
        },
        "rowSums": {
            "signatures": [
                "(numeric)rowSums(lif\u00a0x)"
            ],
            "description": "Returns the sums of the rows of x, which must be a matrix.\u00a0 The result is a vector of elements, each providing the sum of the corresponding row of x.\u00a0 If x is of type logical or integer the result will be of type integer; unlike the sum() function, rowSums() does not promote the return type to float if integer overflow occurs, but instead throws an error.\u00a0 If x is of type float the result will be of type float.\u00a0 Except for the change in the treatment of integer overflow noted above, this is equivalent to using apply() with sum() to sum the rows of x, but is much faster."
        },
        "t": {
            "signatures": [
                "(*)t(*\u00a0x)"
            ],
            "description": "Returns the transpose of x, which must be a matrix.\u00a0 This is the matrix reflected across its diagonal; or alternatively, the matrix with its columns written out instead as rows in the same order."
        },
        "tr": {
            "signatures": [
                "(numeric$)tr(numeric\u00a0x)"
            ],
            "description": "Returns the trace of x, which must be a square matrix (otherwise an error is raised).\u00a0 The trace is the sum of the diagonal elements of the matrix.\u00a0 The return type will match the type of x."
        },
        "upperTri": {
            "signatures": [
                "(logical)upperTri(*\u00a0x, [logical$\u00a0diag\u00a0=\u00a0F])"
            ],
            "description": "Returns the upper triangle of x, which must be a matrix.\u00a0 The return value will be a logical matrix of the same dimensions as x, with elements T in the upper triangle, F elsewhere.\u00a0 If diag is F (the default), the diagonal is not included in the upper triangle; if diag is T, the diagonal is included in the upper triangle (i.e., its elements will be T)."
        }
    },
    "Filesystem access functions": {
        "createDirectory": {
            "signatures": [
                "(logical$)createDirectory(string$\u00a0path)"
            ],
            "description": "Creates a new filesystem directory at the path specified by path and returns a logical value indicating if the creation succeeded (T) or failed (F).\u00a0 If the path already exists, createDirectory() will do nothing to the filesystem, will emit a warning, and will return T to indicate success if the existing path is a directory, or F to indicate failure if the existing path is not a directory."
        },
        "deleteFile": {
            "signatures": [
                "(logical$)deleteFile(string$\u00a0filePath)"
            ],
            "description": "Deletes the file specified by filePath and returns a logical value indicating if the deletion succeeded (T) or failed (F). This function might also be able to delete a directory at filePath, but only if it is empty (apart from the . and .. directory entries that exist on Un*x filesystems).\u00a0 If other files (including invisible files) exist in the directory, deleteFile() will probably fail as a safety measure, in which case the contained files must be deleted individually first.\u00a0 This is vague because the actual policy regarding deletion of directories will depend upon the operating system, since Eidos achieves the deletion by calling an operating-system function."
        },
        "fileExists": {
            "signatures": [
                "(logical$)fileExists(string$\u00a0filePath)"
            ],
            "description": "Checks the existence of the file specified by filePath and returns a logical value indicating if it exists (T) or does not exist (F).\u00a0 This also works for directories."
        },
        "filesAtPath": {
            "signatures": [
                "(string)filesAtPath(string$\u00a0path, [logical$\u00a0fullPaths\u00a0=\u00a0F])"
            ],
            "description": "Returns a string vector containing the names of all files in a directory specified by path.\u00a0 If the optional parameter fullPaths is T, full filesystem paths are returned for each file; if fullPaths is F (the default), then only the filenames relative to the specified directory are returned.\u00a0 This list includes directories (i.e. subfolders), including the \".\" and \"..\" directories on Un*x systems.\u00a0 The list also includes invisible files, such as those that begin with a \".\" on Un*x systems.\u00a0 This function does not descend recursively into subdirectories.\u00a0 If an error occurs during the read, NULL will be returned."
        },
        "flushFile": {
            "signatures": [
                "(logical$)flushFile(string$\u00a0filePath)"
            ],
            "description": "Flushes buffered content to a file specified by filePath.\u00a0 Normally, written data is buffered by writeFile() if the compress option of that function is T, holding the data in memory rather than writing it to disk immediately.\u00a0 This buffering improves both performance and file size; however, sometimes it is desirable to flush the buffered data to disk with flush() so that the filesystem is up to date.\u00a0 Note that flushing after every write is not recommended, since it will lose all of the benefits of buffering.\u00a0 Calling flushFile() for a path that has not been written to, or is not being buffered, will do nothing.\u00a0 If the flush is successful, T will be returned; if not, F will be returned (but at present, an error will result instead)."
        },
        "getwd": {
            "signatures": [
                "(string$)getwd(void)"
            ],
            "description": "Gets the current filesystem working directory.\u00a0 The filesystem working directory is the directory which will be used as a base path for relative filesystem paths.\u00a0 For example, if the working directory is \"~/Desktop\" (the Desktop subdirectory within the current user\u2019s home directory, as represented by ~), then the filename \"foo.txt\" would correspond to the filesystem path \"~/Desktop/foo.txt\", and the relative path \"bar/baz/\" would correspond to the filesystem path \u201c~/Desktop/bar/baz/\u201c. Note that the path returned may not be identical to the path previously set with setwd(), if for example symbolic links are involved; but it ought to refer to the same actual directory in the filesystem. The initial working directory is \u2013 as is generally the case on Un*x \u2013 simply the directory given to the running Eidos process by its parent process (the operating system, a shell, a job scheduler, a debugger, or whatever the case may be).\u00a0 If you launch Eidos (or SLiM) from the command line in a Un*x shell, it is typically the current directory in that shell.\u00a0 Before relative filesystem paths are used, you may therefore wish check what the initial working directory is on your platform, with getwd(), if you are not sure.\u00a0 Alternatively, you can simply use setwd() to set the working directory to a known path."
        },
        "readCSV": {
            "signatures": [
                "(object<DataFrame>$)readCSV(string$\u00a0filePath, [ls\u00a0colNames\u00a0=\u00a0T], [Ns$\u00a0colTypes\u00a0=\u00a0NULL], [string$\u00a0sep\u00a0=\u00a0\",\"], [string$\u00a0quote\u00a0=\u00a0'\"'], [string$\u00a0dec\u00a0=\u00a0\".\"], [string$\u00a0comment\u00a0=\u00a0\"\"])"
            ],
            "description": "Reads data from a CSV or other delimited file specified by filePath and returns a DataFrame object containing the data in a tabular form.\u00a0 CSV (comma-separated value) files use a somewhat standard file format in which a table of data is provided, with values within a row separated by commas, while rows in the table are separated by newlines.\u00a0 Software from R to Excel (and Eidos; see the serialize() method of Dictionary) can export data in CSV format.\u00a0 This function can actually also read files that use a delimiter other than commas; TSV (tab-separated value) files are a popular alternative.\u00a0 Since there is substantial variation in the exact file format for CSV files, this documentation will try to specify the precise format expected by this function.\u00a0 Note that CSV files represent values differently that Eidos usually does, and some of the format options allowed by readCSV(), such as decimal commas, are not otherwise available in Eidos. If colNames is T (the default), the first row of data is taken to be a header, containing the string names of the columns in the data table; those names will be used by the resulting DataFrame.\u00a0 If colNames is F, a header row is not expected and column names are auto-generated as X1, X2, etc.\u00a0 If colNames is a string vector, a header row is not expected and colNames will be used as the column names; if additional columns exist beyond the length of colNames their names will be auto-generated.\u00a0 Duplicate column names will generate a warning and be made unique. If colTypes is NULL (the default), the value type for each column will be guessed from the values it contains, as described below.\u00a0 If colTypes is a singleton string, it should contain single-letter codes indicating the desired type for each column, from left to right.\u00a0 The letters lifs have the same meaning as in Eidos signatures (logical, integer, float, and string); in addition, ? may be used to indicate that the type for that column should be guessed as by default, and _ or - may be used to indicate that that column should be skipped \u2013 omitted from the returned DataFrame.\u00a0 Other characters in colTypes will result in an error.\u00a0 If additional columns exist beyond the end of the colTypes string their types will be guessed as by default. The separator between values is supplied by sep; it is a comma by default, but a tab can be used instead by supplying tab (\"\\t\" in Eidos), or another character may also be used.\u00a0 If sep is the empty string \"\", the separator between values is \u201cwhitespace\u201d, meaning one or more spaces or tabs.\u00a0 When the separator is whitespace, whitespace at the beginning or the end of a line will be ignored. Similarly, the character used to quote string values is a double quote ('\"' in Eidos), by default, but another character may be supplied in quote.\u00a0 When the string delimiter is encountered, all following characters are considered to be part of the string until another string delimiter is encountered, terminating the string; this includes spaces, comment characters, newlines, and everything else.\u00a0 Within a string value, the string delimiter itself is used twice in a row to indicate that the delimiter itself is present within the string; for example, if the string value (shown without the usual surrounding quotes to try to avoid confusion) is she said \"hello\", and the string delimiter is the double quote as it is by default, then in the CSV file the value would be given as \"she said \"\"hello\"\"\".\u00a0 The usual Eidos style of escaping characters using a backslash is not part of the CSV standard followed here.\u00a0 (When a string value is provided without using the string delimiter, all following characters are considered part of the string except a newline, the value separator sep, the quote separator quote, and the comment separator comment; if none of those characters are present in the string value, the quote delimiter may be omitted.) The character used to indicate a decimal delimiter in numbers may be supplied with dec; by default this is \".\" (and so 10.0 would be ten, written with a decimal point), but \",\" is common in European data files (and so 10,0 would be ten, written with a decimal comma).\u00a0 Note that dec and sep may not be the same, so that it is unambiguous whether 10,0 is two numbers (10 and 0) or one number (10.0).\u00a0 For this reason, European CSV files that use a decimal comma typically use a semicolon as the value separator, which may be supplied with sep=\";\" to readCSV(). Finally, the remainder of a line following a comment character will be ignored when the file is read; by default comment is the empty string, \"\", indicating that comments do not exist at all, but \"#\" is a popular comment prefix. To translate the CSV data into a DataFrame, it is necessary for Eidos to guess what value type each column is unless a column type is specified by colTypes.\u00a0 Quotes surrounding a value are irrelevant to this guess; for example, 1997 and \"1997\" are both candidates to be integer values (because some programs generate CSV output in which every value is quoted regardless of type).\u00a0 If every value in a column is either true, false, TRUE, FALSE, T, or F, the column will be taken to be logical.\u00a0 Otherwise, if every value in a column is an integer (here defined as an optional + or -, followed by nothing but decimal digits 0123456789), the column will be taken to be integer.\u00a0 Otherwise, if every value in a column is a floating-point number (here defined as an optional + or -, followed by decimal digits 0123456789, optionally a decimal separator and then optionally more decimal digits, and ending with an optional exponent like e7, E+05, or e-2), the column will be taken to be float; the special values NAN, INF, INFINITY, -INF, and -INFINITY (not case-sensitive) are also candidates to be float (if the rest of the column is also convertible to float), representing the corresponding float constants.\u00a0 Otherwise, the column will be taken to be string.\u00a0 NULL and NA are not recognized by readCSV() in CSV files and will be read as strings.\u00a0 Every line in a CSV file must contain the same number of values (forming a rectangular data table); missing values are not allowed by readCSV() since there is no way to represent them in DataFrame (since Eidos has no equivalent of R\u2019s NA value).\u00a0 Spaces are considered part of a data field and are not trimmed, following the RFC 4180 standard.\u00a0 These choices are an attempt to provide optimal behavior for most clients, but given the lack of any universal standard for CSV files, and the lack of any type information in the CSV format, they will not always work as desired; in such cases, it should be reasonably straightforward to preprocess input files using standard Unix text-processing tools like sed and awk."
        },
        "readFile": {
            "signatures": [
                "(string)readFile(string$\u00a0filePath)"
            ],
            "description": "Reads in the contents of a file specified by filePath and returns a string vector containing the lines (separated by \\n and \\r characters) of the file.\u00a0 Reading files other than text files is not presently supported.\u00a0 If an error occurs during the read, NULL will be returned."
        },
        "setwd": {
            "signatures": [
                "(string$)setwd(string$\u00a0path)"
            ],
            "description": "Sets the current filesystem working directory.\u00a0 The filesystem working directory is the directory which will be used as a base path for relative filesystem paths (see getwd() for further discussion).\u00a0 An error will result if the working directory cannot be set to the given path. The current working directory prior to the change will be returned as an invisible string value; the value returned is identical to the value that would have been returned by getwd(), apart from its invisibility. See getwd() for discussion regarding the initial working directory, before it is set with setwd()."
        },
        "tempdir": {
            "signatures": [
                "(string$)tempdir(void)"
            ],
            "description": "Returns a path to a directory appropriate for saving temporary files.\u00a0 The path returned by tempdir() is platform-specific, and is not guaranteed to be the same from one run of SLiM to the next.\u00a0 It is guaranteed to end in a slash, so further path components should be appended without a leading slash.\u00a0 At present, on macOS and Linux systems, the path will be \"/tmp/\"; this may change in future Eidos versions without warning."
        },
        "writeFile": {
            "signatures": [
                "(logical$)writeFile(string$\u00a0filePath, string\u00a0contents, [logical$\u00a0append\u00a0=\u00a0F], [logical$\u00a0compress\u00a0=\u00a0F])"
            ],
            "description": "Writes or appends to a file specified by filePath with contents specified by contents, a string vector of lines.\u00a0 If append is T, the write will be appended to the existing file (if any) at filePath; if it is F (the default), then the write will replace an existing file at that path.\u00a0 If the write is successful, T will be returned; if not, F will be returned (but at present, an error will result instead). If compress is T, the contents will be compressed with zlib as they are written, and the standard .gz extension for gzip-compressed files will be appended to the filename in filePath if it is not already present.\u00a0 If the compress option is used in conjunction with append==T, Eidos will buffer data to append and flush it to the file in a delayed fashion (for performance reasons), and so appended data may not be visible in the file until later \u2013 potentially not until the process ends (i.e., the end of the SLiM simulation, for example).\u00a0 If that delay if undesirable, buffered data can be explicitly flushed to the filesystem with flushFile().\u00a0 The compress option was added in Eidos 2.4 (SLiM 3.4).\u00a0 Note that readFile() does not currently support reading in compressed data. Note that newline characters will be added at the ends of the lines in contents.\u00a0 If you do not wish to have newlines added, you should use paste() to assemble the elements of contents together into a singleton string."
        },
        "writeTempFile": {
            "signatures": [
                "(string$)writeTempFile(string$\u00a0prefix, string$\u00a0suffix, string\u00a0contents, [logical$\u00a0compress\u00a0=\u00a0F])"
            ],
            "description": "Writes to a unique temporary file with contents specified by contents, a string vector of lines.\u00a0 The filename used will begin with prefix and end with suffix, and will contain six random characters in between; for example, if prefix is \"plot1_\" and suffix is \".pdf\", the generated filename might look like \"plot1_r5Mq0t.pdf\".\u00a0 It is legal for prefix, suffix, or both to be the empty string, \"\", but supplying a file extension is usually advisable at minimum.\u00a0 The file will be created inside the /tmp/ directory of the system, which is provided by Un*x systems as a standard location for temporary files; the /tmp/ directory should not be specified as part of prefix (nor should any other directory information).\u00a0 The filename generated is guaranteed not to already exist in /tmp/.\u00a0 The file is created with Un*x permissions 0600, allowing reading and writing only by the user for security.\u00a0 If the write is successful, the full path to the temporary file will be returned; if not, \"\" will be returned. If compress is T, the contents will be compressed with zlib as they are written, and the standard .gz extension for gzip-compressed files will be appended to the filename suffix in suffix if it is not already present.\u00a0 The compress option was added in Eidos 2.4 (SLiM 3.4).\u00a0 Note that readFile() does not currently support reading in compressed data. Note that newline characters will be added at the ends of the lines in contents.\u00a0 If you do not wish to have newlines added, you should use paste() to assemble the elements of contents together into a singleton string."
        }
    },
    "Color manipulation functions": {
        "cmColors": {
            "signatures": [
                "(string)cmColors(integer$\u00a0n)"
            ],
            "description": "This method has been deprecated, and may be removed in a future release of Eidos.\u00a0 In SLiM 3.5 and later, use colors(n, \"cm\") instead."
        },
        "colors": {
            "signatures": [
                "(string)colors(numeric\u00a0x, string$\u00a0name)"
            ],
            "description": "Generate colors in a standard color palette.\u00a0 If x is a singleton integer, the returned vector will contain x color strings representing x colors equidistant along the named palette, spanning its full extent.\u00a0 Alternatively, if x is a float vector of values in [0,1], the returned vector will contain one color string for each value in x, representing the color at the corresponding fraction along the named palette (values outside [0,1] will be clamped to that range).\u00a0 (Note that the function signature states the type of x as numeric, but in this function the integer and float cases have completely different semantic meanings.) The color palette specified by name may be any of the following color palettes based upon color palettes in R: \"cm\", \"heat\", and \"terrain\". It may also be one of the following color palettes based on color palettes in MATLAB (and the Turbo palette from Anton Mikhailov of the Google AI group, based upon the Jet palette provided by MATLAB): \"parula\", \"hot\", \"jet\", \"turbo\", and \"gray\". Finally, it may be one of the following color palettes based upon color palettes in Matplotlib, also available in the viridis R package: \"magma\", \"inferno\", \"plasma\", \"viridis\", and \"cividis\".\u00a0 These color palettes are designed to be perceptually uniform, changing continuously and linearly.\u00a0 They are also designed to perform well even for users with red-green colorblindness; the \"cividis\" palette, in particular, is designed to look nearly identical to those with and without red-green colorblindness, to be perceptually uniform in both hue and brightness, and to increase linearly in brightness. This function replaces the deprecated cmColors(), heatColors(), and terrainColors() functions, and adds several several additional color palettes to Eidos.\u00a0 See rainbow() for another color palette function."
        },
        "color2rgb": {
            "signatures": [
                "(float)color2rgb(string\u00a0color)"
            ],
            "description": "Converts a color string to RGB.\u00a0 The color string specified in color may be either a named color or a color in hexadecimal format such as \"#007FC0\".\u00a0 The equivalent RGB color is returned as a float vector of length three (red, green, blue).\u00a0 Returned RGB values will be in the interval [0, 1]. This function can also be called with a non-singleton vector of color strings in color.\u00a0 In this case, the returned float value will be a matrix of RGB values, with three columns (red, green, blue) and one row per element of color."
        },
        "heatColors": {
            "signatures": [
                "(string)heatColors(integer$\u00a0n)"
            ],
            "description": "This method has been deprecated, and may be removed in a future release of Eidos.\u00a0 In SLiM 3.5 and later, use colors(n, \"heat\") instead."
        },
        "hsv2rgb": {
            "signatures": [
                "(float)hsv2rgb(float\u00a0hsv)"
            ],
            "description": "Converts an HSV color to RGB.\u00a0 The HSV color is specified in hsv as a float vector of length three (hue, saturation, value), and the equivalent RGB color is returned as a float vector of length three (red, green, blue).\u00a0 HSV values will be clamped to the interval [0, 1], and returned RGB values will also be in the interval [0, 1]. This function can also be called with a matrix of HSV values, with three columns (hue, saturation, value).\u00a0 In this case, the returned float value will be a matrix of RGB values, with three columns (red, green, blue) and one row per row of hsv."
        },
        "rainbow": {
            "signatures": [
                "(string)rainbow(integer$\u00a0n, [float$\u00a0s\u00a0=\u00a01.0], [float$\u00a0v\u00a0=\u00a01.0], [float$\u00a0start\u00a0=\u00a00.0], [Nf$\u00a0end\u00a0=\u00a0NULL], [logical$\u00a0ccw\u00a0=\u00a0T])"
            ],
            "description": "Generate colors in a \u201crainbow\u201d color palette.\u00a0 The number of colors desired is passed in n, and the returned vector will contain n color strings.\u00a0 Parameters s and v control the saturation and value of the rainbow colors generated.\u00a0 The color sequence begins with the hue start, and ramps to the hue end, in a counter-clockwise direction around the standard HSV color wheel if ccw is T (the default, following R), otherwise in a clockwise direction.\u00a0 If end is NULL (the default), a value of (n-1)/n is used, producing a complete rainbow around the color wheel when start is also the default value of 0.0.\u00a0 See colors() for other color palettes."
        },
        "rgb2color": {
            "signatures": [
                "(string)rgb2color(float\u00a0rgb)"
            ],
            "description": "Converts an RGB color to a color string.\u00a0 The RGB color is specified in rgb as a float vector of length three (red, green, blue).\u00a0 The equivalent color string is returned as singleton string specifying the color in the format \"#RRGGBB\", such as \"#007FC0\".\u00a0 RGB values will be clamped to the interval [0, 1]. This function can also be called with a matrix of RGB values, with three columns (red, green, blue).\u00a0 In this case, the returned string value will be a vector of color strings, with one element per row of rgb."
        },
        "rgb2hsv": {
            "signatures": [
                "(float)rgb2hsv(float\u00a0rgb)"
            ],
            "description": "Converts an RGB color to HSV.\u00a0 The RGB color is specified in rgb as a float vector of length three (red, green, blue), and the equivalent HSV color is returned as a float vector of length three (hue, saturation, value).\u00a0 RGB values will be clamped to the interval [0, 1], and returned HSV values will also be in the interval [0, 1]. This function can also be called with a matrix of RGB values, with three columns (red, green, blue).\u00a0 In this case, the returned float value will be a matrix of HSV values, with three columns (hue, saturation, value) and one row per row of rgb."
        },
        "terrainColors": {
            "signatures": [
                "(string)terrainColors(integer$\u00a0n)"
            ],
            "description": "This method has been deprecated, and may be removed in a future release of Eidos.\u00a0 In SLiM 3.5 and later, use colors(n, \"terrain\") instead."
        }
    },
    "Miscellaneous functions": {
        "assert": {
            "signatures": [
                "(void)assert(logical\u00a0assertions, [Ns$\u00a0message\u00a0=\u00a0NULL])"
            ],
            "description": "Assert that a condition or conditions are true.\u00a0 If any element of assertions is F, execution will be stopped.\u00a0 A message, \u201cassertion failed\u201d, will be printed before stopping; if message is not NULL; its value will then be printed."
        },
        "beep": {
            "signatures": [
                "(void)beep([Ns$\u00a0soundName\u00a0=\u00a0NULL])"
            ],
            "description": "Plays a sound or beeps.\u00a0 On macOS in a GUI environment (i.e., in EidosScribe or SLiMgui), the optional parameter soundName can be the name of a sound file to play; in other cases (if soundName is NULL, or at the command line, or on platforms other than OS X) soundName is ignored and a standard system beep is played. When soundName is not NULL, a sound file in a supported format (such as .aiff or .mp3) is searched for sequentially in four standard locations, in this order: ~/Library/Sounds, /Library/Sounds, /Network/Library/Sounds, and finally /System/Library/Sounds.\u00a0 Standard OS X sounds located in /System/Library/Sounds include \"Basso\", \"Blow\", \"Bottle\", \"Frog\", \"Funk\", \"Glass\", \"Hero\", \"Morse\", \"Ping\", \"Pop\", \"Purr\", \"Sosumi\", \"Submarine\", and \"Tink\".\u00a0 Do not include the file extension, such as .aiff or .mp3, in soundName. CAUTION: When not running in EidosScribe or SLiMgui, it is often the case that the only simple means available to play a beep is to send a BEL character (ASCII 7) to the standard output.\u00a0 Unfortunately, when this is the case, it means that (1) no beep will be audible if output is being redirected into a file, and (2) a control character, ^G, will occur in the output at the point when the beep was requested.\u00a0 It is therefore recommended that beep() be used only when doing interactive work in a terminal shell (or in a GUI), not when producing output files.\u00a0 However, this issue is platform-specific; on some platforms beep() may result in a beep, and no emitted ^G, even when output is redirected.\u00a0 When a ^G must be emitted to the standard output to generate the beep, a warning message will also be emitted to make any associated problems easier to diagnose."
        },
        "citation": {
            "signatures": [
                "(void)citation(void)"
            ],
            "description": "Prints citation information for Eidos to Eidos\u2019s output stream."
        },
        "clock": {
            "signatures": [
                "(float$)clock([string$\u00a0type\u00a0=\u00a0\"cpu\"])"
            ],
            "description": "Returns the value of a system clock.\u00a0 If type is \"cpu\", this returns the current value of the CPU usage clock.\u00a0 This is the amount of CPU time used by the current process, in seconds; it is unrelated to the current time of day (for that, see the time() function).\u00a0 This is useful mainly for determining how much processor time a given section of code takes; clock() can be called before and after a block of code, and the end clock minus the start clock gives the elapsed CPU time consumed in the execution of the block of code.\u00a0 See also the timed parameter of executeLambda(), which automates this procedure.\u00a0 Note that if multiple cores are utilized by the process, the CPU usage clock will be the sum of the CPU usage across all cores, and may therefore run faster than the wall clock. If type is \"mono\", this returns the value of the system\u2019s monotonic clock.\u00a0 This represents user-perceived (\u201cwall clock\u201d) elapsed time from some arbitrary timebase (which will not change during the execution of the program), but it will not jump if the time zone or the wall clock time are changed for the system.\u00a0 This clock is useful for measuring user-perceived elapsed time, as described above, and may provide a more useful metric for performance than CPU time if multiple cores are being utilized."
        },
        "date": {
            "signatures": [
                "(string$)date(void)"
            ],
            "description": "Returns a standard date string for the current date in the local time of the executing machine.\u00a0 The format is %d-%m-%Y (day in two digits, then month in two digits, then year in four digits, zero-padded and separated by dashes) regardless of the localization of the executing machine, for predictability and consistency."
        },
        "debugIndent": {
            "signatures": [
                "(string$)debugIndent(void)"
            ],
            "description": "Returns the indentation string currently being used to start lines in the debugging output stream.\u00a0 In a pure Eidos context this will currently be the empty string, \"\".\u00a0 In specific Contexts, such as SLiM, the debugging output stream may be structured with nested indentation, in which case this string will typically be a series of spaces or tabs.\u00a0 To make your debugging output (such as from cat(), catn(), or print() with the error=T optional argument set) line up with other output at the current level of execution nesting, you can start your new lines of output with this string if you wish."
        },
        "defineConstant": {
            "signatures": [
                "(void)defineConstant(string$\u00a0symbol, *\u00a0value)"
            ],
            "description": "Defines a new constant with the name symbol and the value specified by value.\u00a0 The name cannot previously be defined in any way (i.e., as either a variable or a constant).\u00a0 The defined constant acts identically to intrinsic Eidos constants such as T, NAN, and PI, and will remain defined for as long as the Eidos context lives even if it is defined inside a block being executed by executeLambda(), apply(), sapply(), or a Context-defined script block. Syntactically, value may be any value at all; semantically, however, if value is of object type then value\u2019s class must be under an internal memory-management scheme called \u201cretain-release\u201d.\u00a0 Objects that are not under retain-release can cease to exist whenever the Context is finished using them, and thus a defined constant referencing such an object could become invalid, which must be prevented.\u00a0 Objects that are under retain-release will not cease to exist if they are referenced by a global constant; the reference to them from the global constant \u201cretains\u201d them and keeps them in existence.\u00a0 All object classes built into Eidos are under retain-release; see the SLiM manual (section \u201cSLiM scoping rules\u201d) for discussion of which SLiM object classes are under retain-release."
        },
        "defineGlobal": {
            "signatures": [
                "(void)defineGlobal(string$\u00a0symbol, *\u00a0value)"
            ],
            "description": "Defines a new global variable with the name symbol and the value specified by value.\u00a0 The name cannot previously be defined as a constant.\u00a0 The result is similar to a standard variable assignment with operator =, except that the variable is always defined in the global scope (even if the defineGlobal() call is made inside a user-defined function or other locally-scoped block, such as a SLiM event or callback).\u00a0 This means that the variable will remain defined even after the current scope is exited.\u00a0 Note that global variables can be hidden by local variables with the same name; unlike defined constants, such scoped masking is allowed. Syntactically, value may be any value at all; semantically, however, if value is of object type then value\u2019s class must be under an internal memory-management scheme called \u201cretain-release\u201d.\u00a0 Objects that are not under retain-release can cease to exist whenever the Context is finished using them, and thus a global variable referencing such an object could become invalid, which must be prevented.\u00a0 Objects that are under retain-release will not cease to exist if they are referenced by a global variable; the reference to them from the global variable \u201cretains\u201d them and keeps them in existence.\u00a0 All object classes built into Eidos are under retain-release; see the SLiM manual (section \u201cSLiM scoping rules\u201d) for discussion of which SLiM object classes are under retain-release."
        },
        "doCall": {
            "signatures": [
                "(vNlifso)doCall(string$\u00a0functionName, ...)"
            ],
            "description": "Returns the results from a call to a specified function.\u00a0 The function named by the parameter functionName is called, and the remaining parameters to doCall() are forwarded on to that function verbatim.\u00a0 This can be useful for calling one of a set of similar functions, such as sin(), cos(), etc., to perform a math function determined at runtime, or one of the as...() family of functions to convert to a type determined at runtime.\u00a0 Note that named arguments and default arguments, beyond the functionName argument, are not supported by doCall(); all arguments to the target function must be specified explicitly, without names."
        },
        "executeLambda": {
            "signatures": [
                "(vNlifso)executeLambda(string$\u00a0lambdaSource, [ls$\u00a0timed\u00a0=\u00a0F])"
            ],
            "description": "Executes a block of Eidos code defined by lambdaSource.\u00a0 Eidos allows you to execute lambdas: blocks of Eidos code which can be called directly within the same scope as the caller.\u00a0 Eidos lambdas do not take arguments; for this reason, they are not first-class functions.\u00a0 (Since they share the scope of the caller, however, you may effectively pass values in and out of a lambda using variables.)\u00a0 The string argument lambdaSource may contain one or many Eidos statements as a single string value.\u00a0 Lambdas are represented, to the caller, only as the source code string lambdaSource; the executable code is not made available programmatically.\u00a0 If an error occurs during the tokenization, parsing, or execution of the lambda, that error is raised as usual; executing code inside a lambda does not provide any additional protection against exceptions raised.\u00a0 The return value produced by the code in the lambda is returned by executeLambda().\u00a0 If the optional parameter timed is T, the total (CPU clock) execution time for the lambda will be printed after the lambda has completed (see clock()); if it is F (the default), no timing information will be printed.\u00a0 The timed parameter may also be \"cpu\" or \"mono\" to specifically request timing with the CPU clock (which will count the usage across all cores, and may thus run faster than wall clock time if multiple cores are being utilized) or the monotonic clock (which will correspond, more or less, to elapsed wall clock time regardless of multithreading); see the documentation for clock() for further discussion of these timing options. The current implementation of executeLambda() caches a tokenized and parsed version of lambdaSource, so calling executeLambda() repeatedly on a single source string is much more efficient than calling executeLambda() with a newly constructed string each time.\u00a0 If you can use a string literal for lambdaSource, or reuse a constructed source string stored in a variable, that will improve performance considerably."
        },
        "exists": {
            "signatures": [
                "(logical)exists(string\u00a0symbol)"
            ],
            "description": "Returns a logical vector indicating whether symbols exist.\u00a0 If a symbol has been defined as an intrinsic Eidos constant like T, INF, and PI, or as a Context-defined constant like sim in SLiM, or as a user-defined constant using defineConstant(), or as a variable by assignment, this function returns T.\u00a0 Otherwise, the symbol has not been defined, and exists() returns F.\u00a0 This is commonly used to check whether a user-defined constant already exists, with the intention of defining the constant if it has not already been defined.\u00a0 A vector of symbols may be passed, producing a vector of corresponding results."
        },
        "functionSignature": {
            "signatures": [
                "(void)functionSignature([Ns$\u00a0functionName\u00a0=\u00a0NULL])"
            ],
            "description": "Prints function signatures for all functions (if functionName is NULL, the default), or for the function named by functionName, to Eidos\u2019s output stream."
        },
        "functionSource": {
            "signatures": [
                "(void)functionSource(string$\u00a0functionName)"
            ],
            "description": "Prints the Eidos source code for the function specified by functionName, or prints a diagnostic message if the function is implemented in C++ rather than Eidos."
        },
        "getSeed": {
            "signatures": [
                "(integer$)getSeed(void)"
            ],
            "description": "Returns the random number seed.\u00a0 This is the last seed value set using setSeed(); if setSeed() has not been called, it will be a seed value chosen based on the process-id and the current time when Eidos was initialized, unless the Context has set a different seed value."
        },
        "license": {
            "signatures": [
                "(void)license(void)"
            ],
            "description": "Prints Eidos\u2019s license terms to Eidos\u2019s output stream."
        },
        "ls": {
            "signatures": [
                "(void)ls([logical$\u00a0showSymbolTables\u00a0=\u00a0F])"
            ],
            "description": "Prints all currently defined variables to Eidos\u2019s output stream. Beginning in Eidos 2.5 (SLiM 3.5), the showSymbolTables optional argument can be set to T to request full information on the current symbol table chain.\u00a0 This will show which symbol table a given symbol is defined in, as well as revealing whether there are other symbols with the same name that have been masked by a local definition.\u00a0 This is mostly useful for debugging."
        },
        "parallelGetNumThreads": {
            "signatures": [
                "(integer$)parallelGetNumThreads(void)"
            ],
            "description": "Gets the number of threads that is requested be used in subsequent parallel (i.e., multithreaded) regions, as set with parallelSetNumThreads().\u00a0 If Eidos is not configured to run multithreaded, this function will return 1.\u00a0 See also parallelGetMaxThreads(), which returns the maximum number of threads that can be used.\u00a0 Note that if this function returns the maximum number of threads, as returned by parallelGetMaxThreads(), then there are two possible semantic meanings of that return value, which cannot be distinguished using this function; see parallelSetNumThreads() for discussion."
        },
        "parallelGetMaxThreads": {
            "signatures": [
                "(integer$)parallelGetMaxThreads(void)"
            ],
            "description": "Gets the maximum number of threads that can be used in parallel (i.e., multithreaded) regions.\u00a0 This is configured externally; it may be OpenMP\u2019s default number of threads for the hardware platform being used, or may be set by an environment variable or command-line option.\u00a0 If Eidos is not configured to run multithreaded, this function will return 1."
        },
        "parallelGetTaskThreadCounts": {
            "signatures": [
                "(object<Dictionary>$)parallelGetTaskThreadCounts(void)"
            ],
            "description": "Gets the number of threads that is requested to be used for specific tasks in Eidos and SLiM.\u00a0 Returns a new Dictionary containing values for all of the tasks for which a number of threads can be specified; see parallelSetTaskThreadCounts() for a list of all such tasks.\u00a0 Note that the specified number of threads will not necessarily be used in practice; in particular, a thread count set by parallelSetNumThreads() will override these per-task counts.\u00a0 Also, if the task size is below a certain task-specific threshold the task will not be executed in parallel regardless of these settings."
        },
        "parallelSetNumThreads": {
            "signatures": [
                "(void)parallelSetNumThreads([Ni$\u00a0numThreads\u00a0=\u00a0NULL])"
            ],
            "description": "Sets the number of threads that is requested to be used in subsequent parallel (i.e., multithreaded) regions.\u00a0 If Eidos is not configured to run multithreaded, this function will have no effect.\u00a0 The requested number of threads will be clamped to the interval [1, maxThreads], where maxThreads is the maximum number of threads configured externally (either by OpenMP\u2019s default, or by an environment variable or command-line option).\u00a0 That maximum number of threads (the value of maxThreads) can be obtained from parallelGetMaxThreads(). There is an important wrinkle in the semantics of this method that must be explained.\u00a0 Passing NULL (the default) resets Eidos to the default number of threads for which it is configured to run.\u00a0 In this configuration, parallelGetNumThreads() will return maxThreads, but the number of threads used for any given parallel operation might not, in fact, be equal to maxThreads; Eidos might use fewer threads if it determines that that would improve performance.\u00a0 Passing the value of maxThreads explicitly, on the other hand, sets Eidos to always use maxThreads threads, even if it may result in lower performance; but in this configuration, too, parallelGetNumThreads() will return maxThreads.\u00a0 For example, suppose maxThreads is 16.\u00a0 Passing NULL requests that Eidos use up to 16 threads, as it sees fit; in contrast, explicitly passing 16 requests that Eidos use exactly 16 threads.\u00a0 In both cases, however, parallelGetNumThreads() will return 16. If you wish to temporarily change the number of threads used, the standard pattern is to call parallelSetNumThreads() with the number of threads you want to use, do the operation you wish to control, and then call parallelSetNumThreads(NULL) to return to the default behavior of Eidos. Note that the number of threads requested here overrides any per-task request set with parallelSetTaskThreadCounts().\u00a0 Also, if the task size is below a certain task-specific threshold the task will not be executed in parallel regardless of these settings."
        },
        "parallelSetTaskThreadCounts": {
            "signatures": [
                "(void)parallelSetTaskThreadCounts(No<Dictionary>$\u00a0dict)"
            ],
            "description": "Sets the number of threads that is requested to be used for specific tasks in Eidos and SLiM.\u00a0 The dictionary dict should contain string keys that identify tasks, and integer values that provide the number of threads to be used when performing those tasks.\u00a0 For example, a key of \"LOG10_FLOAT\" identifies the task of performing the log10() function on a float vector, and a value of 8 for that key would tell Eidos to use eight threads when performing that task.\u00a0 The number of threads actually used will never be greater than the maximum thread count as returned by parallelGetMaxThreads().\u00a0 Furthermore, a thread count set with parallelSetNumThreads() overrides the per-task setting, so if you wish to set specific per-task thread counts you should not set an overall thread count with parallelSetNumThreads().\u00a0 If dict is NULL, all task thread counts will be reset to their default values. The currently requested thread counts for all tasks can be obtained with parallelGetTaskThreadCounts().\u00a0 Note that the counts returned by that function may not match the counts requested with parallelSetTaskThreadCounts(); in particular, they may be clipped to the maximum number of threads as returned by parallelGetMaxThreads(). The task keys recognized, and the tasks they govern, are: Typically, a dictionary of task keys and thread counts is read from a file and set up with this function at initialization time, but it is also possible to change new task thread counts dynamically.\u00a0 If Eidos is not configured to run multithreaded, this function has no effect."
        },
        "rm": {
            "signatures": [
                "(void)rm([Ns\u00a0variableNames\u00a0=\u00a0NULL])"
            ],
            "description": "Removes variables from the Eidos namespace; in other words, it causes the variables to become undefined.\u00a0 Variables are specified by their string name in the variableNames parameter.\u00a0 If the optional variableNames parameter is NULL (the default), all variables will be removed (be careful!). In SLiM 3, there was an optional parameter removeConstants that, if T, allowed you to remove defined constants (and then potentially redefine them to have a different value).\u00a0 The removeConstants parameter was removed in SLiM 4, since the defineGlobal() function now provides the ability to define (and redefine) global variables that are not constant."
        },
        "sapply": {
            "signatures": [
                "(*)sapply(*\u00a0x, string$\u00a0lambdaSource, [string$\u00a0simplify\u00a0=\u00a0\"vector\"])"
            ],
            "description": "Applies a block of Eidos code to the elements of x.\u00a0 This function is sort of a hybrid between c() and executeLambda(); it might be useful to consult the documentation for both of those functions to better understand what sapply() does.\u00a0 For each element in x, the lambda defined by lambdaSource will be called.\u00a0 For the duration of that callout, a variable named applyValue will be defined to have as its value the element of x currently being processed.\u00a0 The expectation is that the lambda will use applyValue in some way, and will return either NULL or a new value (which need not be a singleton, and need not be of the same type as x).\u00a0 The return value of sapply() is generated by concatenating together all of the individual vectors returned by the lambda, in exactly the same manner as the c() function (including the possibility of type promotion). Since this function can be hard to understand at first, here is an example: This produces the output 1 9 25 49 81.\u00a0 The sapply() operation begins with the vector 1:10.\u00a0 For each element of that vector, the lambda is called and applyValue is defined with the element value.\u00a0 In this respect, sapply() is actually very much like a for loop.\u00a0 If applyValue is even (as evaluated by the modulo operator, %), the condition of the if statement is F and so NULL is returned by the lambda; this must be done explicitly, since a void return is not allowed by sapply().\u00a0 If applyValue is odd, on the other hand, the lambda returns its square (as calculated by the exponential operator, ^).\u00a0 Just as with the c() function, NULL values are dropped during concatenation, so the final result contains only the squares of the odd values. This example illustrates that the lambda can \u201cdrop\u201d values by returning NULL, so sapply() can be used to select particular elements of a vector that satisfy some condition, much like the subscript operator, [].\u00a0 The example also illustrates that input and result types do not have to match; the vector passed in is integer, whereas the result vector is float. Beginning in Eidos 1.6, a new optional parameter named simplify allows the result of sapply() to be a matrix or array in certain cases, better organizing the elements of the result.\u00a0 If the simplify parameter is \"vector\", the concatenated result value is returned as a plain vector in all cases; this is the default behavior, for backward compatibility.\u00a0 Two other possible values for simplify are presently supported.\u00a0 If simplify is \"matrix\", the concatenated result value will be turned into a matrix with one column for each non-NULL value returned by the lambda, as if the values were joined together with cbind(), as long as all of the lambda\u2019s return values are either (a) NULL or (b) the same length as the other non-NULL values returned.\u00a0 If simplify is \"match\", the concatenated result value will be turned into a vector, matrix, or array that exactly matches the dimensions as x, with a one-to-one correspondence between x and the elements of the return value just like a unary operator, as long as all of the lambda\u2019s return values are singletons (with no NULL values).\u00a0 Both \"matrix\" and \"match\" will raise an error if their preconditions are not met, to avoid unexpected behavior, so care should be taken that the preconditions are always met when these options are used. As with executeLambda(), all defined variables are accessible within the lambda, and changes made to variables inside the lambda will persist beyond the end of the sapply() call; the lambda is executing in the same scope as the rest of your code. The sapply() function can seem daunting at first, but it is an essential tool in the Eidos toolbox.\u00a0 It combines the iteration of a for loop, the ability to select elements like operator [], and the ability to assemble results of mixed type together into a single vector like c(), all with the power of arbitrary Eidos code execution like executeLambda().\u00a0 It is relatively fast, compared to other ways of achieving similar results such as a for loop that accumulates results with c().\u00a0 Like executeLambda(), sapply() is most efficient if it is called multiple times with a single string script variable, rather than with a newly constructed string for lambdaSource each time. Prior to Eidos 1.6 (SLiM 2.6), sapply() was instead named apply(); it was renamed to sapply() in order to more closely match the naming of functions in R.\u00a0 This renaming allowed a new apply() function to be added to Eidos that operates on the margins of matrices and arrays, similar to the apply() function of R (see apply(), above)."
        },
        "setSeed": {
            "signatures": [
                "(void)setSeed(integer$\u00a0seed)"
            ],
            "description": "Set the random number seed.\u00a0 Future random numbers will be based upon the seed value set, and the random number sequence generated from a particular seed value is guaranteed to be reproducible.\u00a0 The last seed set can be recovered with the getSeed() function."
        },
        "source": {
            "signatures": [
                "(void)source(string$\u00a0filePath, [logical$\u00a0chdir\u00a0=\u00a0F])"
            ],
            "description": "Executes the contents of an Eidos source file found at the filesystem path filePath.\u00a0 This is essentially shorthand for calling readFile(), joining the read lines with newlines to form a single string using paste(), and then passing that string to executeLambda().\u00a0 The source file must consist of complete Eidos statements.\u00a0 Regardless of what the last executed source line evaluates to, source() has no return value.\u00a0 If no file exists at filePath, an error will be raised. The chdir parameter controls the current working directory in effect while the source file is executed.\u00a0 If chdir is F (the default), the current working directory will remain unchanged.\u00a0 If chdir is T, the current working directory will be temporarily changed to the filesystem path at which the source file is located, and restored after execution of the source file is complete."
        },
        "stop": {
            "signatures": [
                "(void)stop([Ns$\u00a0message\u00a0=\u00a0NULL])"
            ],
            "description": "Stops execution of Eidos (and of the Context, such as the running SLiM simulation, if applicable), in the event of an error.\u00a0 If the optional message parameter is not NULL, it will be printed to Eidos\u2019s output stream prior to stopping."
        },
        "suppressWarnings": {
            "signatures": [
                "(logical$)suppressWarnings(logical$\u00a0suppress)"
            ],
            "description": "Turns suppression of warning messages on or off.\u00a0 The suppress flag indicates whether suppression of warnings should be enabled (T) or disabled (F).\u00a0 The previous warning-suppression value is returned by suppressWarnings(), making it easy to suppress warnings from a given call and then return to the previous suppression state afterwards.\u00a0 It is recommended that warnings be suppressed only around short blocks of code (not all the time), so that unexpected but perhaps important warnings are not missed.\u00a0 And of course warnings are generally emitted for good reasons; before deciding to disregard a given warning, make sure that you understand exactly why it is being issued, and are certain that it does not represent a serious problem."
        },
        "sysinfo": {
            "signatures": [
                "(*)sysinfo(string$\u00a0key)"
            ],
            "description": "Returns information about the system.\u00a0 The information returned by tempdir() depends upon the value of key, which selects one of the pieces of information listed: The value \"unknown\" will be returned for a key if the correct value cannot be ascertained.\u00a0 Note that the values of keys that refer to the kernel may not be what you expect; for example, on one particular macOS 10.15.7 system, sysname returns \"Darwin\", release returns \"19.6.0\", and version returns \"Darwin Kernel Version 19.6.0: Thu Sep 16 20:58:47 PDT 2021; root:xnu-6153.141.40.1~1/RELEASE_X86_64\". Further keys can be added if there is information that would be useful, particularly if a cross-platform way to obtain the information can be found."
        },
        "system": {
            "signatures": [
                "(string)system(string$\u00a0command, [string\u00a0args\u00a0=\u00a0\"\"], [string\u00a0input\u00a0=\u00a0\"\"], [logical$\u00a0stderr\u00a0=\u00a0F], [logical$\u00a0wait\u00a0=\u00a0T])"
            ],
            "description": "Runs a Un*x command in a /bin/sh shell with optional arguments and input, and returns the result as a vector of output lines.\u00a0 The args parameter may contain a vector of arguments to command; they will be passed directly to the shell without any quoting, so applying the appropriate quoting as needed by /bin/sh is the caller\u2019s responsibility.\u00a0 The arguments are appended to command, separated by spaces, and the result is passed to the shell as a single command string, so arguments may simply be given as part of command instead, if preferred.\u00a0 By default no input is supplied to command; if input is non-empty, however, it will be written to a temporary file (one line per string element) and the standard input of command will be redirected to that temporary file (using standard /bin/sh redirection with <, appended to the command string passed to the shell).\u00a0 By default, output sent to standard error will not be captured (and thus may end up in the output of the SLiM process, or may be lost); if stderr is T, however, the standard error stream will be redirected into standard out (using standard /bin/sh redirection with 2>&1, appended to the command string passed to the shell). Arbitrary command strings involving multiple commands, pipes, redirection, etc., may be used with system(), but may be incompatible with the way that args, input, and stderr are handled by this function, so in this case supplying the whole command string in command may be the simplest course.\u00a0 You may redirect standard error into standard output yourself in command with 2>&1.\u00a0 Supplying input to a complex command line can often be facilitated by the use of parentheses to create a subshell; for example, will supply the input lines to wc courtesy of the subshell started for the () operator.\u00a0 If this strategy doesn\u2019t work for the command line you want to execute, you can always write a temporary file yourself using writeFile() or writeTempFile() and redirect that file to standard input in command with <. If wait is T (the default), system() will wait for the command to finish, and return the output generated as a string vector, as described above.\u00a0 If wait is F, system() will instead append \" &\" to the end of the command line to request that it be run in the background, and it will not collect and return the output from the command; instead it will return string(0) immediately.\u00a0 If the output from the command is needed, it could be redirected to a file, and that file could be checked periodically in Eidos for some indication that the command had completed; if output is not redirected to a file, it may appear in SLiM\u2019s output stream.\u00a0 If the final command line executed by system() ends in \" &\", the behavior of system() should be just as if wait=T had been supplied, but it is recommended to use wait=T instead to ensure that the command line is correctly assembled. There is an example at https://github.com/MesserLab/SLiM-Extras/blob/master/functions/rgnorm.slim that demonstrates the use of system(), calling out to Python, to obtain draws from a generalized normal distribution (which is not supported intrinsically by Eidos).\u00a0 That example even includes internal buffering of a large number of draws, making it a reasonably efficient solution."
        },
        "time": {
            "signatures": [
                "(string$)time(void)"
            ],
            "description": "Returns a standard time string for the current time in the local time of the executing machine.\u00a0 The format is %H:%M:%S (hour in two digits, then minute in two digits, then seconds in two digits, zero-padded and separated by dashes) regardless of the localization of the executing machine, for predictability and consistency.\u00a0 The 24-hour clock time is used (i.e., no AM/PM)."
        },
        "usage": {
            "signatures": [
                "(float$)usage([ls$\u00a0type\u00a0=\u00a0\"rss\"])"
            ],
            "description": "Returns the memory usage.\u00a0 This is the amount of memory used by the current process, in MB (megabytes); multiply by 1024*1024 to get the usage in bytes. Memory usage is a surprisingly complex topic.\u00a0 One metric reported by usage() is the resident set size, or RSS, which includes memory usage from shared libraries, but does not include memory that is swapped out or has never been used.\u00a0 For most purposes, RSS is a useful metric of memory usage from a practical perspective.\u00a0 On some platforms (AIX, BSD, Solaris) the memory usage reported may be zero, but it should be correct on both macOS and Linux platforms.\u00a0 On macOS, memory pages that have not been used for a while may get compressed by the kernel to reduce the RSS of the process; the RSS metric reported by usage() will reflect the compressed size of such pages, not their original size, so surprising decreases in memory usage may be observed when the kernel decides to compress some memory pages.\u00a0 The RSS is requested with a type of \"rss\", which is the default; for historical reasons, it can also be requested with a type of F. Another metric reported by usage() is the peak RSS.\u00a0 This is just the highest RSS value that has ever been recorded by the kernel.\u00a0 It should generally mirror the behavior of RSS, except that it ratchets upward monotonically.\u00a0 The peak RSS is requested with a type of \"rss_peak\"; for historical reasons, it can also be requested with a type of T. The third metric currently reported by usage() is the virtual memory usage.\u00a0 This is essentially the amount of memory used by pages that have been assigned to the process, whether those pages are resident, compressed, or swapped.\u00a0 It is typically much larger than the RSS, because it includes various types of memory that are not counted in the RSS; indeed, for some system configurations the virtual memory usage can be reported as being the entire memory space of the computer.\u00a0 Whether it is a useful metric will be platform-dependent; caveat emptor. This function can be useful for documenting the memory usage of long runs as they are in progress.\u00a0 In SLiM, the RSS could also be used to trigger tree-sequence simplification with a call to treeSeqSimplify(), to reduce memory usage when it becomes too large, but keep in mind that the simplification process itself may cause a substantial spike in memory usage, and that page compression and swaps may reduce the RSS even though the memory actually used by tree-sequence recording continues to increase. When running under SLiM, other tools for monitoring memory usage include the slim command-line options -m[em] and -M[emhist], and the usage() and outputUsage() methods of Community; see the SLiM manual for more information."
        },
        "version": {
            "signatures": [
                "(float)version([logical$\u00a0print\u00a0=\u00a0T])"
            ],
            "description": "Get Eidos\u2019s version.\u00a0 There are two ways to use this function.\u00a0 If print is T, the default, then the version number is printed to the Eidos output stream in a formatted manner, like \u201cEidos version 2.1\u201d.\u00a0 If Eidos is attached to a Context that provides a version number, that is also printed, like \u201cSLiM version 3.1\u201d.\u00a0 In this case, the Eidos version number, and the Context version number if available, are returned as an invisible float vector.\u00a0 This is most useful when using Eidos interactively.\u00a0 If print is F, on the other hand, nothing is printed, but the returned float vector of version numbers is not invisible.\u00a0 This is useful for scripts that need to test the Eidos or Context version they are running against. In both cases, in the float version numbers returned, a version like 2.4.2 would be returned as 2.42; this would not scale well to subversions greater than nine, so that will be avoided in our versioning."
        }
    }
}