{
    "Initialization functions": {
        "initializeAncestralNucleotides": {
            "signatures": [
                "(integer$)initializeAncestralNucleotides(is\u00a0sequence)"
            ],
            "description": "This function, which may be called only in nucleotide-based models, supplies an ancestral nucleotide sequence for the model.\u00a0 The sequence parameter may be an integer vector providing nucleotide values (A=0, C=1, G=2, T=3), or a string vector providing single-character nucleotides (\"A\", \"C\", \"G\", \"T\"), or a singleton string providing the sequence as one string (\"ACGT...\"), or a singleton string providing the filesystem path of a FASTA file which will be read in to provide the sequence (if the file contains than one sequence, the first sequence will be used).\u00a0 Only A/C/G/T nucleotide values may be provided; other symbols, such as those for amino acids, gaps, or nucleotides of uncertain identity, are not allowed.\u00a0 The two semantic meanings of sequence that involve a singleton string value are distinguished heuristically; a singleton string that contains only the letters ACGT will be assumed to be a nucleotide sequence rather than a filename.\u00a0 The length of the ancestral sequence is returned. A utility function, randomNucleotides(), is provided by SLiM to assist in generating simple random nucleotide sequences."
        },
        "initializeChromosome": {
            "signatures": [
                "(object<Chromosome>$)initializeChromosome(integer$\u00a0id, [Ni$\u00a0length\u00a0=\u00a0NULL], [string$\u00a0type\u00a0=\u00a0\"A\"], [Ns$\u00a0symbol\u00a0=\u00a0NULL], [Ns$\u00a0name\u00a0=\u00a0NULL], [integer$\u00a0mutationRuns\u00a0=\u00a00])"
            ],
            "description": "Calling this function, added in SLiM\u00a05, initiates the configuration of a chromosome in the species being initialized.\u00a0 The new Chromosome object is returned, but it is still under construction and will error if used; see below for details.\u00a0 That chromosome is then the \u201cfocal chromosome\u201d for subsequent genetic initialization functions \u2013 specifically, for initializeAncestralNucleotides(), initializeGeneConversion(), initializeGenomicElement(), initializeHotspotMap(), initializeMutationRate(), and initializeRecombinationRate().\u00a0 If you wish to call initializeChromosome() at all (which is not required), you must call it before calling any of those genetic initialization functions, so that the focal chromosome is created before being configured further; otherwise, SLiM will assume that you want a default single-chromosome model, and when initializeChromosome() is called later (contradicting that assumption), an error will result. Furthermore, there are some other initialization functions must be called before initializeChromosome() if they are called at all \u2013 specifically, initializeSex(), initializeTreeSeq(), initializeSpecies(), and initializeSLiMOptions().\u00a0 This is so that initializeChromosome() knows the context within which the new chromosome is to be created; if these methods have not been called when initializeChromosome() is called, the default context is assumed (non-sexual, no tree-sequence recording, single-species, non-nucleotide-based), and an error will result downstream if one of those functions is later called (indicating that those assumptions might be incorrect). The parameters to initializeChromosome() configure the chromosome created.\u00a0 They will be discussed out of order here, because that order of presentation will, I hope, be clearer. There are three parameters that in some way identify the chromosome.\u00a0 First, the required id parameter provides an integer identifier for the chromosome, which can be used to look up the chromosome later in the simulation; it can be any non-negative integer value, but must be unique within the species (two chromosomes in the same species cannot have the same id).\u00a0 Often it is an empirical chromosome number, for convenience and clarity; if modeling human chromosome 7, for example, you might provide 7.\u00a0 Second, the symbol parameter provides a string identifier for the chromosome, which can also be used to look up the chromosome later in the simulation.\u00a0 If NULL (the default) is passed for symbol, the chromosome\u2019s default symbol value will be the string version of its id (\"7\" for an id of 7, for example).\u00a0 The chromosome\u2019s symbol value will be used to identify the chromosome in output \u2013 in VCF output, for example, and in SLiMgui.\u00a0 It must be non-empty (not \"\"), no more than five characters long, and unique within the species.\u00a0 Third, the name parameter can be any string value; if NULL (the default) is passed, the name value will be \"\".\u00a0 The name is not used by SLiM, and can be used in any way you wish. The length parameter sets the length, in base positions, of the chromosome, and must either be NULL, or an integer greater than or equal to 1.\u00a0 If length is NULL, the length of the chromosome will be calculated after all initialize() callbacks have been called, as the maximum position referenced by the chromosome\u2019s genomic elements, recombination map, mutation rate map, and (in nucleotide-based models) hotspot map; in other words, the chromosome will be sized to encompass all of the things it contains (which is also the behavior of the implicitly defined chromosome if initializeChromosome() is not called).\u00a0 Otherwise \u2013 if length is specified with an integer value \u2013 the chromosome\u2019s length will be fixed at that value, and the last valid base position in the chromosome will be length-1.\u00a0 Attempting to add a genomic element or a mutation after the last position will raise an error.\u00a0 Similarly, the last position of the chromosome must match the last position specified for recombination, mutation, and hotspot maps for that chromosome, but not all positions on a chromosome have to actually be used in the model (i.e., not all positions must be covered by a genomic element). The type parameter specifies the type of chromosome to be created.\u00a0 There are numerous options, and they are somewhat complex.\u00a0 They are discussed in more detail in the documentation for class Chromosome, particularly their specific patterns of inheritance; but they are briefly summarized here for quick reference.\u00a0 Note that \u201c\u2013\u201c below indicates a null haplosome.\u00a0 First of all, in hermaphroditic models type will generally be one of: \"A\" (autosome), the default, specifying a diploid autosomal chromosome. \"H\" (haploid), specifying a haploid autosomal chromosome that recombines in biparental crosses. \"HF\" (haploid female-inherited), specifying a haploid autosomal chromosome that is inherited by both sexes from the first (female) parent in biparental crosses (also allowed in hermaphroditic models for inheritance that is always from the first parent). \"HM\" (haploid male-inherited), specifying a haploid autosomal chromosome that is inherited by both sexes from the second (male) parent in biparental crosses (also allowed in hermaphroditic models for inheritance that is always from the second parent). Some sex-chromosome types are supported only in sexual models: \"X\" (X), specifying an X chromosome that is diploid (XX) in females, haploid (X\u2013) in males. \"Y\" (Y), specifying a Y chromosome that is haploid (Y) in males, absent (\u2013) in females. \"Z\" (Z), specifying a Z chromosome that is diploid (ZZ) in males, haploid (\u2013Z) in females. \"W\" (W), specifying a W chromosome that is haploid (W) in females, absent (\u2013) in males. And there are some haploid chromosome types that are also supported only in sexual models: \"FL\" (female line), specifying a haploid autosomal chromosome that is inherited only by females, from the female parent, and is represented by a null haplosome in males. \"ML\" (male line), specifying a haploid autosomal chromosome that is inherited only by males, from the male parent, and is represented by a null haplosome in females. Finally, two additional values of type, \"H-\" and \"-Y\", are supported for backward compatibility (not intended for use in new models).\u00a0 They are discussed in the Chromosome documentation. The mutationRuns parameter specifies how many mutation runs the chromosome should use.\u00a0 Internally, SLiM divides haplosomes into a sequence of consecutive mutation runs, allowing more efficient internal computations.\u00a0 The optimal mutation run length is short enough that each mutation run is relatively unlikely to be modified by mutation/recombination events when inherited, but long enough that each mutation run is likely to contain a relatively large number of mutations; these priorities are in tension, so an intermediate balance between them is generally optimal.\u00a0 The optimal number of mutation runs will depend on the model\u2019s details, and may also depend upon the machine and even the compiler used to build SLiM.\u00a0 If the mutationRuns parameter is not 0, SLiM will use the value given as the number of mutation runs inside Haplosome objects for the chromosome.\u00a0 If mutationRuns is 0 (the default), then the behavior depends upon a parameter to the initializeSLiMOptions() function, doMutationRunExperiments.\u00a0 If that flag is F, the behavior here is as if mutationRuns=1 had been passed: one mutation run will be used, and mutation run experiments will not be conducted.\u00a0 If that flag is T (the default), then for mutationRuns=0 SLiM will conduct experiments at runtime, using different mutation run counts, to try to determine the number of mutation runs that produces the best performance.\u00a0 The value that SLiM\u2019s experiments determine may not be optimal, however, and in any case there is some overhead associated with conducting these experiments; for maximal performance it can thus be beneficial to determine the true optimal value for the simulation yourself, and set it explicitly using this parameter. Specifying the number of mutation runs is an advanced technique, but in some cases it can improve performance significantly. The order in which initializeChromosome() calls are made is generally unimportant, since the chromosomes assort independently of each other anyway, but SLiM will preserve the order in which they were defined for you (for the chromosomes property of Species, for display in SLiMgui, for writing out to VCF, and so forth).\u00a0 All of the above types of chromosomes can be defined any number of times; you can have any number of autosomal chromosomes, for example.\u00a0 In a sexual model you could even have multiple defined sex chromosomes \u2013 not in the sense of a female being XX, but in the sense of a female being X1X1X2X2, where X1 and X2 are two different kinds of X chromosome.\u00a0 Similarly, you could define both an X and a Z for a species, if you wish; each would segregate correctly according to the sex of the offspring.\u00a0 In sexual models in SLiM the sex of an offspring is determined randomly or given by the user in script; it is not a function of the sex chromosomes present in the individual, although the sex chromosomes present in the individual will correlate with sex.\u00a0 In other words, SLiM does not know and does not care what sex-determination system the species is using; the chromosomes follow the sex, rather than the sex following the chromosomes.\u00a0 This should allow any sex-determination system to be modeled, even if it is unusual, non-genetic, etc. As stated above, the new Chromosome object is returned by this call, but it is still under construction so most of its methods and properties will error.\u00a0 It will remain in this state until initialize() callbacks have completed, and will then become active and usable.\u00a0 Until that point, there are only a handful of uses that are guaranteed to be allowed: storing it in a variable; remembering it with defineConstant(); using the methods and properties of its superclasses, notably Dictionary; setting SLiMgui display-related properties such as colorSubstitution; getting and setting its tag property; and accessing those of its properties that were passed to the initializeChromosome() call, specifically id, symbol, name, type, length, and lastPosition.\u00a0 Its other properties, and all Chromosome methods, will raise an error while in this state.\u00a0 This safeguard protects the new Chromosome object from being used while still in an inconsistent state."
        },
        "initializeGeneConversion": {
            "signatures": [
                "(void)initializeGeneConversion(numeric$\u00a0nonCrossoverFraction, numeric$\u00a0meanLength, numeric$\u00a0simpleConversionFraction, [numeric$\u00a0bias\u00a0=\u00a00], [logical$\u00a0redrawLengthsOnFailure\u00a0=\u00a0F])"
            ],
            "description": "Calling this function switches the recombination model from a \u201csimple crossover\u201d model to a \u201cdouble-stranded break (DSB)\u201d model, and configures the details of the gene conversion tracts that will therefore be modeled.\u00a0 The fraction of DSBs that will be modeled as non-crossover events is given by nonCrossoverFraction.\u00a0 The mean length of gene conversion tracts (whether associated with crossover or non-crossover events) is given by meanLength; the actual extent of a gene conversion tract will be the sum of two independent draws from a geometric distribution with mean meanLength/2.\u00a0 The fraction of gene conversion tracts that are modeled as \u201csimple\u201d is given by simpleConversionFraction; the remainder will be modeled as \u201ccomplex\u201d, involving repair of heteroduplex mismatches.\u00a0 Finally, the GC bias during heteroduplex mismatch repair is given by bias, with the default of 0.0 indicating no bias, 1.0 indicating an absolute preference for G/C mutations over A/T mutations, and -1.0 indicating an absolute preference for A/T mutations over G/C mutations.\u00a0 A non-zero bias may only be set in nucleotide-based models.\u00a0 This function, and the way that gene conversion is modeled, fundamentally changed in SLiM 3.3. Beginning in SLiM 4.1, the redrawLengthsOnFailure parameter can be used to modify the internal mechanics of layout of gene conversion tracts.\u00a0 If it is F (the default, and the only behavior supported before SLiM 4.1), then if an attempt to lay out gene conversion tracts fails (because the tracts overlap each other, or overlap the start or end of the chromosome), SLiM will try again by drawing new positions for the tracts \u2013 essentially shuffling the tracts around to try to find positions for them that don\u2019t overlap.\u00a0 If redrawLengthsOnFailure is T, then if an attempt to lay out gene conversion tracts fails, SLiM will try again by drawing new lengths for the tracts, as well as new positions.\u00a0 This makes it more likely that layout will succeed, but risks biasing the realized mean tract length downward from the requested mean length (since layout of long tracts is more likely fail due to overlap).\u00a0 In either case, if SLiM attempts to lay out gene conversion tracts 100 times without success, an error will result.\u00a0 That error indicates that the specified constraints for gene conversion are difficult to satisfy \u2013 tracts may commonly be so long that it is difficult or impossible to find an acceptable layout for them within the specified chromosome length.\u00a0 Setting redrawLengthsOnFailure to T may mitigate this problem, at the price of biasing the mean tract length downward as discussed."
        },
        "initializeGenomicElement": {
            "signatures": [
                "(object<GenomicElement>)initializeGenomicElement(io<GenomicElementType>\u00a0genomicElementType, [Ni\u00a0start\u00a0=\u00a0NULL], [Ni\u00a0end\u00a0=\u00a0NULL])"
            ],
            "description": "Add a genomic element to the chromosome at initialization time.\u00a0 The start and end parameters give the first and last base positions to be spanned by the new genomic element.\u00a0 The new element will be based upon the genomic element type identified by genomicElementType, which can be either an integer, representing the ID of the desired element type, or an object of type GenomicElementType specified directly. Beginning in SLiM 3.3, this function is vectorized: the genomicElementType, start, and end parameters do not have to be singletons.\u00a0 In particular, start and end may be of any length, but must be equal in length; each start/end element pair will generate one new genomic element spanning the given base positions.\u00a0 In this case, genomicElementType may still be a singleton, providing the genomic element type to be used for all of the new genomic elements, or it may be equal in length to start and end, providing an independent genomic element type for each new element.\u00a0 When adding a large number of genomic elements, it will be much faster to add them in order of ascending position with a vectorized call. Beginning in SLiM 5, passing NULL for start and end is allowed by initializeGenomicElement(), but only in one specific case: if the focal chromosome being configured was explicitly defined with initializeChromosome(), and that focal chromosome was given an explicit length (rather than a length of NULL).\u00a0 In that case, start and end may be NULL (both of them, not just one of them), indicating that the genomic element created should span the entire length of the focal chromosome.\u00a0 Since NULL is now the default value for start and end, this makes this common configuration very simple to set up. The return value provides the genomic element(s) created by the call, in the order in which they were specified in the parameters to initializeGenomicElement()."
        },
        "initializeGenomicElementType": {
            "signatures": [
                "(object<GenomicElementType>$)initializeGenomicElementType(is$\u00a0id, io<MutationType>\u00a0mutationTypes, numeric\u00a0proportions, [Nf\u00a0mutationMatrix\u00a0=\u00a0NULL])"
            ],
            "description": "The mutationMatrix parameter is NULL by default, and in non-nucleotide-based models it must be NULL.\u00a0 In nucleotide-based models, on the other hand, it must be non-NULL, and therefore must be supplied.\u00a0 In that case, mutationMatrix should take one of two standard forms.\u00a0 For sequence-based mutation rates that depend upon only the single nucleotide at a mutation site, mutationMatrix should be a 4\u00d74 float matrix, specifying mutation rates for an existing nucleotide state (rows from 0\u20133 representing A/C/G/T) to each of the four possible derived nucleotide states (columns, with the same meaning).\u00a0 The mutation rates in this matrix are absolute rates, per nucleotide per gamete; they will be used by SLiM directly unless they are multiplied by a factor from the hotspot map (see initializeHotspotMap()).\u00a0 Rates in mutationMatrix that involve the mutation of a nucleotide to itself (A to A, C to C, etc.) are not used by SLiM and must be 0.0 by convention. It is important to note that the order of the rows and columns used in SLiM, A/C/G/T, is not a universal convention; other sources will present substitution-rate/transition-rate matrices using different conventions, and so care must be taken when importing such matrices into SLiM. For sequence-based mutation rates that depend upon the trinucleotide sequence centered upon a mutation site (the adjacent bases to the left and right, in other words, as well as the mutating nucleotide itself), mutationMatrix should be a 64\u00d74 float matrix, specifying mutation rates for the central nucleotide of an existing trinucleotide sequence (rows from 0\u201363, representing codons as described in the documentation for the ancestralNucleotides() method of Chromosome) to each of the four possible derived nucleotide states (columns from 0\u20133 for A/C/G/T as before).\u00a0 Note that in every case it is the central nucleotide of the trinucleotide sequence that is mutating, but rates can be specified independently based upon the nucleotides in the first and third positions as well, with this type of mutation matrix. Several helper functions are defined to construct common types of mutation matrices, such as mmJukesCantor() to create a mutation matrix for a Jukes\u2013Cantor model."
        },
        "initializeHotspotMap": {
            "signatures": [
                "(void)initializeHotspotMap(numeric\u00a0multipliers, [Ni\u00a0ends\u00a0=\u00a0NULL], [string$\u00a0sex\u00a0=\u00a0\"*\"])"
            ],
            "description": "In nucleotide-based models, set the mutation rate multiplier along the chromosome.\u00a0 Nucleotide-based models define sequence-based mutation rates that are set up with the mutationMatrix parameter to initializeGenomicElementType().\u00a0 If no hotspot map is specified by calling initializeHotspotMap(), a hotspot map with a multiplier of 1.0 across the whole chromosome is assumed (and so the sequence-based rates are the absolute mutation rates used by SLiM).\u00a0 A hotspot map modifies the sequence-based rates by scaling them up in some regions, with multipliers greater than 1.0 (representing mutational hot spots), and/or scaling them down in some regions, with multipliers less than 1.0 (representing mutational cold spots). There are two ways to call this function.\u00a0 If the optional ends parameter is NULL (the default), then multipliers must be a singleton value that specifies a single multiplier to be used along the entire chromosome (typically 1.0, but not required to be).\u00a0 If, on the other hand, ends is supplied, then multipliers and ends must be the same length, and the values in ends must be specified in ascending order.\u00a0 In that case, multipliers and ends taken together specify the multipliers to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in ends should extend to the end of the chromosome (i.e. at least to the end of the last genomic element, if not further). For example, if the following call is made: then the result is that the mutation rate multiplier for bases 0...5000 (inclusive) will be 1.0 (and so the specified sequence-based mutation rates will be used verbatim), and the multiplier for bases 5001...9999 (inclusive) will be 1.2 (and so the sequence-based mutation rates will be multiplied by 1.2 within the region). Note that mutations are generated by SLiM only within genomic elements, regardless of the hotspot map.\u00a0 In effect, the hotspot map given is intersected with the coverage area of the genomic elements defined; areas outside of any genomic element are given a multiplier of zero.\u00a0 There is no harm in supplying a hotspot map that specifies multipliers for areas outside of the genomic elements defined; the excess information is simply not used. If the optional sex parameter is \"*\" (the default), then the supplied hotspot map will be used for both sexes (which is the only option for hermaphroditic simulations).\u00a0 In sexual simulations sex may be \"M\" or \"F\" instead, in which case the supplied hotspot map is used only for that sex (i.e., when generating a gamete from a parent of that sex).\u00a0 In this case, two calls must be made to initializeHotspotMap(), one for each sex, even if a multiplier of 1.0 is desired for the other sex; no default hotspot map is supplied."
        },
        "initializeInteractionType": {
            "signatures": [
                "(object<InteractionType>$)initializeInteractionType(is$\u00a0id, string$\u00a0spatiality, [logical$\u00a0reciprocal\u00a0=\u00a0F], [numeric$\u00a0maxDistance\u00a0=\u00a0INF], [string$\u00a0sexSegregation\u00a0=\u00a0\"**\"])"
            ],
            "description": "Add an interaction type at initialization time.\u00a0 The id must not already be used for any interaction type in the simulation.\u00a0 The id parameter may be either an integer giving the ID of the new interaction type, or a string giving the name of the new interaction type (such as \"i5\" to specify an ID of 5). The spatiality may be \"\", for non-spatial interactions (i.e., interactions that do not depend upon the distance between individuals); \"x\", \"y\", or \"z\" for one-dimensional interactions; \"xy\", \"xz\", or \"yz\" for two-dimensional interactions; or \"xyz\" for three-dimensional interactions.\u00a0 The dimensions referenced by spatiality must be defined as spatial dimensions with initializeSLiMOptions(); if the simulation has dimensionality \"xy\", for example, then interactions in the simulation may have spatiality \"\", \"x\", \"y\", or \"xy\", but may not reference spatial dimension z and thus may not have spatiality \"xz\", \"yz\", or \"xyz\".\u00a0 If no spatial dimensions have been configured, only non-spatial interactions may be defined. The reciprocal flag may be T, in which case the interaction is guaranteed by the user to be reciprocal: whatever the interaction strength is for exerter B upon receiver A, it will be equal (in magnitude and sign) for exerter A upon receiver B.\u00a0 In principle, this allows the InteractionType to reduce the amount of computation necessary by up to a factor of two (although it may or may not be used).\u00a0 If reciprocal is F, the interaction is not guaranteed to be reciprocal and each interaction will be computed independently.\u00a0 The built-in interaction formulas are all reciprocal, but if you implement an interaction() callback, you must consider whether the callback you have implemented preserves reciprocality or not.\u00a0 For this reason, the default is reciprocal=F, so that bugs are not inadvertently introduced by an invalid assumption of reciprocality.\u00a0 See below for a note regarding reciprocality in sexual simulations when using the sexSegregation flag. The maxDistance parameter supplies the maximum distance over which interactions of this type will be evaluated; at greater distances, the interaction strength is considered to be zero (for efficiency).\u00a0 The default value of maxDistance, INF (positive infinity), indicates that there is no maximum interaction distance; note that this can make some interaction queries much less efficient, and is therefore not recommended.\u00a0 In SLiM 3.1 and later, a warning will be issued if a spatial interaction type is defined with no maximum distance to encourage a maximum distance to be defined. The sexSegregation parameter governs the applicability of the interaction to each sex, in sexual simulations.\u00a0 It does not affect distance calculations in any way; it only modifies the way in which interaction strengths are calculated.\u00a0 The default, \"**\", implies that the interaction is felt by both sexes (the first character of the string value) and is exerted by both sexes (the second character of the string value).\u00a0 Either or both characters may be M or F instead; for example, \"MM\" would indicate a male-male interaction, such as male-male competition, whereas \"FM\" would indicate an interaction influencing only female receivers that is influenced only by male exerters, such as male mating displays that influence female attraction.\u00a0 This parameter may be set only to \"**\" unless sex has been enabled with initializeSex().\u00a0 Note that a value of sexSegregation other than \"**\" may imply some degree of non-reciprocality, but it is not necessary to specify reciprocal to be F for this reason; SLiM will take the sex-segregation of the interaction into account for you.\u00a0 The value of reciprocal may therefore be interpreted as meaning: in those cases, if any, in which A interacts with B and B interacts with A, is the interaction strength guaranteed to be the same in both directions?\u00a0 The sexSegregation parameter is shorthand for setting sex constraints on the interaction type using the setConstraints() method; see that method for a more extensive set of constraints that may be used. By default, the interaction strength is 1.0 for all interactions within maxDistance.\u00a0 Often it is desirable to change the interaction function using setInteractionFunction(); modifying interaction strengths can also be achieved with interaction() callbacks if necessary.\u00a0 In any case, interactions beyond maxDistance always have a strength of 0.0, and the interaction strength of an individual with itself is always 0.0, regardless of the interaction function or callbacks. The global symbol for the new interaction type is immediately available; the return value also provides the new object.\u00a0 Note that in multispecies models, initializeInteractionType() must be called from a non-species-specific interaction() callback (declared as species all initialize()), since interactions are managed at the community level."
        },
        "initializeMutationRate": {
            "signatures": [
                "(void)initializeMutationRate(numeric\u00a0rates, [Ni\u00a0ends\u00a0=\u00a0NULL], [string$\u00a0sex\u00a0=\u00a0\"*\"])"
            ],
            "description": "Set the mutation rate per base position per gamete.\u00a0 To be precise, this mutation rate is the expected mean number of mutations that will occur per base position per gamete; note that this is different from how the recombination rate is defined (see initializeRecombinationRate()).\u00a0 The number of mutations that actually occurs at a given base position when generating an offspring haplosome is, in effect, drawn from a Poisson distribution with that expected mean (but under the hood SLiM uses a mathematically equivalent but much more efficient strategy).\u00a0 It is possible for this Poisson draw to indicate that two or more new mutations have arisen at the same base position, particularly when the mutation rate is very high; in this case, the new mutations will be added to the site one at a time, and as always the mutation stacking policy will be followed. There are two ways to call this function.\u00a0 If the optional ends parameter is NULL (the default), then rates must be a singleton value that specifies a single mutation rate to be used along the entire chromosome.\u00a0 If, on the other hand, ends is supplied, then rates and ends must be the same length, and the values in ends must be specified in ascending order.\u00a0 In that case, rates and ends taken together specify the mutation rates to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in ends should extend to the end of the chromosome (i.e. at least to the end of the last genomic element, if not further). For example, if the following call is made: then the result is that the mutation rate for bases 0...5000 (inclusive) will be 1e-7, and the rate for bases 5001...9999 (inclusive) will be 2.5e-8. Note that mutations are generated by SLiM only within genomic elements, regardless of the mutation rate map.\u00a0 In effect, the mutation rate map given is intersected with the coverage area of the genomic elements defined; areas outside of any genomic element are given a mutation rate of zero.\u00a0 There is no harm in supplying a mutation rate map that specifies rates for areas outside of the genomic elements defined; that rate information is simply not used.\u00a0 The overallMutationRate family of properties on Chromosome provide the overall mutation rate after genomic element coverage has been taken into account, so it will reflect the rate at which new mutations will actually be generated in the simulation as configured. If the optional sex parameter is \"*\" (the default), then the supplied mutation rate map will be used for both sexes (which is the only option for hermaphroditic simulations).\u00a0 In sexual simulations sex may be \"M\" or \"F\" instead, in which case the supplied mutation rate map is used only for that sex (i.e., when generating a gamete from a parent of that sex).\u00a0 In this case, two calls must be made to initializeMutationRate(), one for each sex, even if a rate of zero is desired for the other sex; no default mutation rate map is supplied. In nucleotide-based models, initializeMutationRate() may not be called.\u00a0 Instead, the desired sequence-based mutation rate(s) should be expressed in the mutationMatrix parameter to initializeGenomicElementType().\u00a0 If variation in the mutation rate along the chromosome is desired, initializeHotspotMap() should be used. The initializeMutationRateFromFile() function is a useful convenience function if you wish to read the mutation rate map from a file."
        },
        "initializeMutationRateFromFile": {
            "signatures": [
                "(void)initializeMutationRateFromFile(string$\u00a0path, integer$\u00a0lastPosition, [float$\u00a0scale\u00a0=\u00a01.0e-08], [string$\u00a0sep\u00a0=\u00a0\"\\t\"], [string$\u00a0dec\u00a0=\u00a0\".\"])"
            ],
            "description": "Set a mutation rate map from data read from the file at path.\u00a0 This function is essentially a wrapper for initializeMutationRate() that uses readCSV() and passes the data through.\u00a0 The file is expected to contain two columns of data.\u00a0 The first column must be integer start positions for rate map regions; the first region should start at position 0 if the map\u2019s positions are 0-based, or at position 1 if the map\u2019s positions are 1-based; in the latter case, 1 will be subtracted from every position since SLiM uses 0-based positions.\u00a0 The second column must be float rates, relative to the scaling factor specified in scale; for example, if a given rate is 1.2 and scale is 1e-8 (the default), the rate used will be 1.2e-8.\u00a0 No column header line should be present; the file should start immediately with numerical data.\u00a0 The expected separator between columns is a tab character by default, but may be passed in sep; the expected decimal separator is a period by default, but may be passed in dec.\u00a0 Once read, the map is converted into a rate map specified with end positions, rather than start positions, and the position given by lastPosition is used as the end of the last rate region; it should be the last position of the chromosome. See readCSV() for further details on sep and dec, which are passed through to it; and see initializeMutationRate() for details on how the rate map is validated and used. This function is written in Eidos, and its source code can be viewed with functionSource(), so you can copy and modify its code if you need to modify its functionality."
        },
        "initializeMutationType": {
            "signatures": [
                "(object<MutationType>$)initializeMutationType(is$\u00a0id, numeric$\u00a0dominanceCoeff, string$\u00a0distributionType, ...)"
            ],
            "description": "Add a mutation type at initialization time.\u00a0 The id must not already be used for any mutation type in the simulation.\u00a0 The id parameter may be either an integer giving the ID of the new mutation type, or a string giving the name of the new mutation type (such as \"m5\" to specify an ID of 5).\u00a0 The dominanceCoeff parameter supplies the dominance coefficient for the mutation type; 0.0 produces no dominance, 1.0 complete dominance, and values greater than 1.0, overdominance.\u00a0 The distributionType may be \"f\", in which case the ellipsis ... should supply a numeric$ fixed selection coefficient; \"e\", in which case the ellipsis should supply a numeric$ mean selection coefficient for an exponential distribution; \"g\", in which case the ellipsis should supply a numeric$ mean selection coefficient and a numeric$ alpha shape parameter for a gamma distribution; \"n\", in which case the ellipsis should supply a numeric$ mean selection coefficient and a numeric$ sigma (standard deviation) parameter for a normal distribution; \"p\", in which case the ellipsis should supply a numeric$ mean selection coefficient and a numeric$ scale parameter for a Laplace distribution; \"w\", in which case the ellipsis should supply a numeric$ \u03bb scale parameter and a numeric$ k shape parameter for a Weibull distribution; or \"s\", in which case the ellipsis should supply a string$ Eidos script parameter.\u00a0 The global symbol for the new mutation type is immediately available; the return value also provides the new object. Note that by default in WF models, all mutations of a given mutation type will be converted into Substitution objects when they reach fixation, for efficiency reasons.\u00a0 If you need to disable this conversion, to keep mutations of a given type active in the simulation even after they have fixed, you can do so by setting the convertToSubstitution property of MutationType to F.\u00a0 In contrast, by default in nonWF models mutations will not be converted into Substitution objects when they reach fixation; convertToSubstitution is F by default in nonWF models.\u00a0 To enable conversion in nonWF models for neutral mutation types with no indirect fitness effects, you should therefore set convertToSubstitution to T."
        },
        "initializeMutationTypeNuc": {
            "signatures": [
                "(object<MutationType>$)initializeMutationTypeNuc(is$\u00a0id, numeric$\u00a0dominanceCoeff, string$\u00a0distributionType, ...)"
            ],
            "description": "Add a nucleotide-based mutation type at initialization time.\u00a0 This function is identical to initializeMutationType() except that the new mutation type will be nucleotide-based \u2013 in other words, mutations belonging to the new mutation type will have an associated nucleotide.\u00a0 This function may be called only in nucleotide-based models (as enabled by the nucleotideBased parameter to initializeSLiMOptions()). Nucleotide-based mutations always use a mutationStackGroup of -1 and a mutationStackPolicy of \"l\".\u00a0 This ensures that a new nucleotide mutation always replaces any previously existing nucleotide mutation at a given position, regardless of the mutation types of the nucleotide mutations.\u00a0 These values are set automatically by initializeMutationTypeNuc(), and may not be changed. See the documentation for initializeMutationType() for all other discussion."
        },
        "initializeRecombinationRate": {
            "signatures": [
                "(void)initializeRecombinationRate(numeric\u00a0rates, [Ni\u00a0ends\u00a0=\u00a0NULL], [string$\u00a0sex\u00a0=\u00a0\"*\"])"
            ],
            "description": "Set the recombination rate per base position per gamete.\u00a0 To be precise, this recombination rate is the probability that a breakpoint will occur between one base and the next base; note that this is different from how the mutation rate is defined (see initializeMutationRate()).\u00a0 A recombination rate of 1 centimorgan/Mbp corresponds to a recombination rate of 1e-8 in the units used by SLiM.\u00a0 All rates must be in the interval [0.0, 0.5].\u00a0 A rate of 0.5 implies complete independence between the adjacent bases, which might be used to implement unlinked loci.\u00a0 Whether a breakpoint occurs between two bases is then, in effect, determined by a binomial draw with a single trial and the given rate as probability (but under the hood SLiM uses a mathematically equivalent but much more efficient strategy).\u00a0 The recombinational process in SLiM will never generate more then one crossover between one base and the next (in one generation/haplosome), and a supplied rate of 0.5 will therefore result in an actual probability of 0.5 for a crossover at the relevant position.\u00a0 (Note that this was not true in SLiM 2.x and earlier, however; their implementation of recombination resulted in a crossover probability of about 39.3% for a rate of 0.5, due to the use of an inaccurate approximation method.\u00a0 Recombination rates lower than about 0.01 would have been essentially exact, since the approximation error became large only as the rate approached 0.5.) There are two ways to call this function.\u00a0 If the optional ends parameter is NULL (the default), then rates must be a singleton value that specifies a single recombination rate to be used along the entire chromosome.\u00a0 If, on the other hand, ends is supplied, then rates and ends must be the same length, and the values in ends must be specified in ascending order.\u00a0 In that case, rates and ends taken together specify the recombination rates to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in ends should extend to the end of the chromosome (i.e. at least to the end of the last genomic element, if not further). If the optional sex parameter is \"*\" (the default), then the supplied recombination rate map will be used for both sexes (which is the only option for hermaphroditic simulations).\u00a0 In sexual simulations sex may be \"M\" or \"F\" instead, in which case the supplied recombination map is used only for that sex.\u00a0 In this case, two calls must be made to initializeRecombinationRate(), one for each sex, even if a rate of zero is desired for the other sex; no default recombination map is supplied. The initializeRecombinationRateFromFile() function is a useful convenience function if you wish to read the recombination rate map from a file."
        },
        "initializeRecombinationRateFromFile": {
            "signatures": [
                "(void)initializeRecombinationRateFromFile(string$\u00a0path, integer$\u00a0lastPosition, [float$\u00a0scale\u00a0=\u00a01.0e-08], [string$\u00a0sep\u00a0=\u00a0\"\\t\"], [string$\u00a0dec\u00a0=\u00a0\".\"], [string$\u00a0sex\u00a0=\u00a0\"*\"])"
            ],
            "description": "Set a recombination rate map from data read from the file at path.\u00a0 This function is essentially a wrapper for initializeRecombinationRate() that uses readCSV() and passes the data through.\u00a0 The file is expected to contain two columns of data.\u00a0 The first column must be integer start positions for rate map regions; the first region should start at position 0 if the map\u2019s positions are 0-based, or at position 1 if the map\u2019s positions are 1-based; in the latter case, 1 will be subtracted from every position since SLiM uses 0-based positions.\u00a0 The second column must be float rates, relative to the scaling factor specified in scale; for example, if a given rate is 1.2 and scale is 1e-8 (the default), the rate used will be 1.2e-8.\u00a0 No column header line should be present; the file should start immediately with numerical data.\u00a0 The expected separator between columns is a tab character by default, but may be passed in sep; the expected decimal separator is a period by default, but may be passed in dec.\u00a0 Once read, the map is converted into a rate map specified with end positions, rather than start positions, and the position given by lastPosition is used as the end of the last rate region; it should be the last position of the chromosome. See readCSV() for further details on sep and dec, which are passed through to it; and see initializeRecombinationRate() for details on how the rate map is validated and used, and how the sex parameter is used. This function is written in Eidos, and its source code can be viewed with functionSource(), so you can copy and modify its code if you need to modify its functionality."
        },
        "initializeSex": {
            "signatures": [
                "(void)initializeSex([Ns$\u00a0chromosomeType\u00a0=\u00a0NULL])"
            ],
            "description": "Enable sex in the simulation.\u00a0 Beginning in SLiM 5, this method should generally be passed NULL, simply indicating that sex should be enabled: individuals will then be male and female (rather than hermaphroditic), biparental crosses will be required to be between a female first parent and a male second parent, and selfing will not be allowed.\u00a0 In this new configuration style, if a sexual simulation involving sex chromosomes is desired, the new initializeChromosome() call should be used to configure the chromosome setup for the simulation. For backward compatibility, the old style of configuring a sexual simulation is still supported, however.\u00a0 This implicitly defines a single chromosome, without a call to initializeChromosome().\u00a0 With this old configuration approach, the chromosomeType parameter to initializeSex() gives the type of chromosome that should be simulated; this should be \"A\", \"X\", or \"Y\", and this chromosomeType value will be used as the symbol (\"A\", \"X\", or \"Y\") for the implicit chromosome.\u00a0 These legacy chromosome types correspond to the new chromosome types \"A\", \"X\", and \"-Y\" respectively (note that it is not \"Y\"), when using initializeChromosome().\u00a0 The implicit chromosome\u2019s id property is always 1.\u00a0 This old style of chromosome configuration is much less flexible, however, allowing only these three chromosome types, and only allowing a single chromosome to be set up.\u00a0 This backward compatibility mode may be removed for SLiM in the future, and should be considered deprecated; new models should call initializeChromosome() explicitly instead. There is no way to disable sex once it has been enabled; if you don\u2019t want to have sex, don\u2019t call this function.\u00a0 If you require more flexibility with mating types and reproductive strategies than SLiM\u2019s built-in support for sex provides, do not call initializeSex(); instead, track the sex or mating type of individuals yourself in script (with the tag property of Individual, for example), and manage the consequences of that in your script yourself, in terms of which individuals can mate with which, and exactly how the offspring is produced."
        },
        "initializeSLiMModelType": {
            "signatures": [
                "(void)initializeSLiMModelType(string$\u00a0modelType)"
            ],
            "description": "Configure the type of SLiM model used for the simulation.\u00a0 At present, one of two model types may be selected.\u00a0 If modelType is \"WF\", SLiM will use a Wright-Fisher (WF) model; this is the model type that has always been supported by SLiM, and is the model type used if initializeSLiMModelType() is not called.\u00a0 If modelType is \"nonWF\", SLiM will use a non-Wright-Fisher (nonWF) model instead; this is a new model type supported by SLiM 3.0 and above. If initializeSLiMModelType() is called at all then it must be called before any other initialization function, so that SLiM knows from the outset which features are enabled and which are not."
        },
        "initializeSLiMOptions": {
            "signatures": [
                "(void)initializeSLiMOptions([logical$\u00a0keepPedigrees\u00a0=\u00a0F], [string$\u00a0dimensionality\u00a0=\u00a0\"\"], [string$\u00a0periodicity\u00a0=\u00a0\"\"], [logical$\u00a0doMutationRunExperiments\u00a0=\u00a0T], [logical$\u00a0preventIncidentalSelfing\u00a0=\u00a0F], [logical$\u00a0nucleotideBased\u00a0=\u00a0F], [logical$\u00a0randomizeCallbacks\u00a0=\u00a0T], [logical$\u00a0checkInfiniteLoops\u00a0=\u00a0T])"
            ],
            "description": "Configure options for the simulation.\u00a0 If initializeSLiMOptions() is called at all then it must be called before any other initialization function (except initializeSLiMModelType()), so that SLiM knows from the outset which optional features are enabled and which are not. If keepPedigrees is T, SLiM will keep pedigree information for every individual in the simulation, tracking the identity of its parents and grandparents.\u00a0 This allows individuals to assess their degree of pedigree-based relatedness to other individuals (see Individual\u2019s relatedness() and sharedParentCount() methods), as well as allowing a model to find \u201ctrios\u201d (two parents and an offspring they generated) using the pedigree properties of Individual.\u00a0 As a side effect of keepPedigrees being T, the pedigreeID, pedigreeParentIDs, and pedigreeGrandparentIDs properties of Individual will have defined values, as will the haplosomePedigreeID property of Haplosome.\u00a0 Note that pedigree-based relatedness doesn\u2019t necessarily correspond to genetic relatedness, due to effects such as assortment and recombination.\u00a0 Beginning in SLiM 3.5, keepPedigrees=T also enables tracking of individual reproductive output, available through the reproductiveOutput property of Individual and the lifetimeReproductiveOutput property of Subpopulation. If periodicity is not \"\", SLiM will designate the specified spatial dimensions as being periodic \u2013 wrapping around at the edges of the spatial boundaries of that dimension.\u00a0 This option may only be used if the dimensionality parameter to initializeSLiMOptions() has been used to enable spatiality in the model, and only spatial dimensions that were specified in the dimensionality of the model may be declared to be periodic (but if desired, it is permissible to make just a subset of those dimensions periodic; it is not an all-or-none proposition).\u00a0 For example, if the specified dimensionality is \"xy\", the model\u2019s periodicity may be \"x\", \"y\", or \"xy\" (or \"\", the default, to specify that there are no periodic dimensions).\u00a0 A one-dimensional periodic model would model a space like the perimeter of a circle.\u00a0 A two-dimensional model periodic in one of those dimensions would model a space like a cylinder without its end caps; if periodic in both dimensions, the modeled space is a torus.\u00a0 The shapes of three-dimensional periodic models are harder to visualize, but are essentially higher-dimensional analogues of these concepts.\u00a0 Periodic boundary conditions are commonly used to model spatial scenarios without \u201cedge effects\u201d, since there are no edges in the periodic spatial dimensions.\u00a0 The pointPeriodic() method of Subpopulation is typically used in conjunction with this option, to actually implement the periodic boundary condition for the specified dimensions. The doMutationRunExperiments parameter specifies whether SLiM should attempt to conduct experiments at runtime to determine the optimal number of mutation runs used in the model.\u00a0 This is a performance optimization.\u00a0 If doMutationRunExperiments is T (the default), this optimization is enabled for all chromosomes that do not have an explicitly specified mutation run count; this is generally desirable and may significantly improve performance.\u00a0 If doMutationRunExperiments is F, this optimization is disabled and chromosomes that do not have an explicitly specified mutation run count will simply use a single mutation run.\u00a0 See the documentation for initializeChromosome() for further discussion.\u00a0 Note that this parameter used to be [integer$\u00a0mutationRuns\u00a0=\u00a00], specifying the mutation run count directly.\u00a0 That parameter has been moved to initializeChromosome(), allowing a different mutation run count to be specified for each chromosome in multi-chromosome models. If nucleotideBased is T, the model will be nucleotide-based.\u00a0 In this case, auto-generated mutations (i.e., mutation types used by genomic element types) must be nucleotide-based, and an ancestral nucleotide sequence must be supplied with initializeAncestralNucleotides().\u00a0 Non-nucleotide-based mutations may still be used, but may not be referenced by genomic element types.\u00a0 A mutation rate (or rate map) may not be supplied with initializeMutationRate(); instead, a hotspot map may (optionally) be supplied with initializeHotspotMap().\u00a0 This choice has many consequences across SLiM. If randomizeCallbacks is T (the default), the order in which individuals are processed in callbacks will be randomized to make it easier to avoid order-dependency bugs.\u00a0 This flag exists because the order of individuals in each subpopulation is non-random; most notably, females always come before males in the individuals vector, but non-random ordering may also occur with respect to things like migrant versus non-migrant status, origin by selfing versus cloning versus biparental mating, and other factors.\u00a0 When this option is F, individuals in a subpopulation are processed in the order of the individuals vector in each tick cycle stage, which may lead to order-dependency issues if there is an enabled callback whose behavior is not fully independent between calls.\u00a0 Setting this option to T will cause individuals within each subpopulation to be processed in a randomized order in each tick cycle stage; specifically, this randomizes the order of calls to mutationEffect() callbacks in both WF and nonWF models, and calls to reproduction() and survival() callbacks in nonWF models.\u00a0 Each subpopulation is still processed separately, in sequential order, so order-dependency issues between subpopulations are still possible if callbacks have effects that are not fully independent.\u00a0 This feature was added in SLiM 4, breaking backward compatibility; to recover the behavior of previous versions of SLiM, pass F for this option (but then be very careful about order-dependency issues in your script).\u00a0 The default of T is the safe option, but a small speed penalty is incurred by the randomization of the processing order \u2013 for most models the difference will be less than 1%, but in the worst case it may approach 10%.\u00a0 Models that do not have any order-dependency issue may therefore run somewhat faster if this is set to F.\u00a0 Note that anywhere that your script uses the individuals property of Subpopulation, the order of individuals returned will be non-random (regardless of the setting of this option); you should use sample() to shuffle the order of the individuals vector if necessary to avoid order-dependency issues in your script. If checkInfiniteLoops is T (the default), SLiM and Eidos will check for infinite loops in various circumstances, such as while and do\u2013while loops.\u00a0 This check is conducted only when running in SLiMgui; at the command line, checks for infinite loops are never conducted regardless of the value of this flag.\u00a0 When checking is enabled, an error will be raised if any loop executes more than 10 million times, preventing SLiMgui\u2019s user interface from freezing.\u00a0 Normally this is desirable, but if you actually want to execute a loop more than 10 million times, this checking will prove inconvenient.\u00a0 In that case, you can pass F for checkInfiniteLoops to disable these checks.\u00a0 There is no way to turn these checks on or off for individual loops; it is a global setting."
        },
        "initializeSpecies": {
            "signatures": [
                "(void)initializeSpecies([integer$\u00a0tickModulo\u00a0=\u00a01], [integer$\u00a0tickPhase\u00a0=\u00a01], [string$\u00a0avatar\u00a0=\u00a0\"\"], [string$\u00a0color\u00a0=\u00a0\"\"])"
            ],
            "description": "Configure options for the species being initialized.\u00a0 This initialization function may only be called in multispecies models (i.e., models with explicit species declarations); in single-species models, the default values are assumed and cannot be changed. The tickModulo and tickPhase parameters determine the activation schedule for the species.\u00a0 The active property of the species will be set to T (thus activating the species) every tickModulo ticks, beginning in tick tickPhase.\u00a0 (However, when the species is activated in a given tick, the skipTick() method may still be called in a first() event to deactivate it.)\u00a0 See the active property of Species for more details. The avatar parameter, if not \"\", sets a string value used to represent the species graphically, particularly in SLiMgui but perhaps in other contexts also.\u00a0 The avatar should generally be a single character \u2013 usually an emoji corresponding to the species, such as \"\ud83e\udd8a\" for foxes or \"\ud83d\udc2d\" for mice.\u00a0 If avatar is the empty string, \"\", SLiMgui will choose a default avatar. The color parameter, if not \"\", sets a string color value used to represent the species in SLiMgui.\u00a0 Colors may be specified by name, or with hexadecimal RGB values of the form \"#RRGGBB\" (see the Eidos manual for details).\u00a0 If color is the empty string, \"\", SLiMgui will choose a default color."
        },
        "initializeTreeSeq": {
            "signatures": [
                "(void)initializeTreeSeq([logical$\u00a0recordMutations\u00a0=\u00a0T], [Nif$\u00a0simplificationRatio\u00a0=\u00a0NULL], [Ni$\u00a0simplificationInterval\u00a0=\u00a0NULL], [logical$\u00a0checkCoalescence\u00a0=\u00a0F], [logical$\u00a0runCrosschecks\u00a0=\u00a0F], [logical$\u00a0retainCoalescentOnly\u00a0=\u00a0T], [Ns$\u00a0timeUnit\u00a0=\u00a0NULL])"
            ],
            "description": "Configure options for tree sequence recording.\u00a0 Calling this function turns on tree sequence recording, as a side effect, for later reconstruction of the simulation\u2019s evolutionary dynamics; if you do not want tree sequence recording to be enabled, do not call this function.\u00a0 Note that tree-sequence recording internally uses SLiM\u2019s \u201cpedigree tracking\u201d feature to uniquely identify individuals and haplosomes; however, if you want to use pedigree tracking in your script you must still enable it yourself with initializeSLiMOptions(keepPedigrees=T).\u00a0 A separate tree sequence will be recorded for each chromosome in the simulation, as configured with initializeChromosome(). The recordMutations flag controls whether information about individual mutations is recorded or not.\u00a0 Such recording takes time and memory, and so can be turned off if only the tree sequence itself is needed, but it is turned on by default since mutation recording is generally useful. The simplificationRatio and simplificationInterval parameters control how often automatic simplification of the recorded tree sequence occurs.\u00a0 This is a speed\u2013memory tradeoff: more frequent simplification (lower simplificationRatio or smaller simplificationInterval) means the stored tree sequences will use less memory, but at a cost of somewhat longer run times.\u00a0 Conversely, a larger simplificationRatio or simplificationInterval means that SLiM will wait longer between simplifications.\u00a0 There are three ways these parameters can be used.\u00a0 With the first option, with a non-NULL simplificationRatio and a NULL value for simplificationInterval, SLiM will try to find an optimal tick interval for simplification such that the ratio of the memory used by the tree sequence tables, (before:after) simplification, is close to the requested ratio. The default of 10 (used if both simplificationRatio and simplificationInterval are NULL) thus requests that SLiM try to find a tick interval such that the maximum size of the stored tree sequences is ten times the size after simplification. INF may be supplied to indicate that automatic simplification should never occur; 0 may be supplied to indicate that automatic simplification should be performed at the end of every tick.\u00a0 Alternatively \u2013 the second option \u2013 simplificationRatio may be NULL and simplificationInterval may be set to the interval, in ticks, between simplifications.\u00a0 This may provide more reliable performance, but the interval must be chosen carefully to avoid exceeding the available memory.\u00a0 The simplificationInterval value may be a very large number to specify that simplification should never occur (not INF, though, since it is an integer value), or 1 to simplify every tick.\u00a0 Finally \u2013 the third option \u2013 both parameters may be non-NULL, in which case simplificationRatio is used as described above, while simplificationInterval provides the initial interval first used by SLiM (and then subsequently increased or decreased to try to match the requested simplification ratio).\u00a0 The default initial interval, used when simplificationInterval is NULL, is usually 20; this is chosen to be relatively frequent, and thus unlikely to lead to a memory overflow, but it can result in rather slow spool-up for models where the equilibrium simplification interval, as determined by the simplification ratio, is much longer.\u00a0 It can therefore be helpful to set a larger initial interval so that the early part of the model run is not excessively bogged down in simplification. The checkCoalescence parameter controls whether a check for full coalescence is conducted after each simplification.\u00a0 If a model will call treeSeqCoalesced() to check for coalescence during its execution, checkCoalescence should be set to T.\u00a0 Since the coalescence checks entail a performance penalty, the default of F is preferable otherwise.\u00a0 See the documentation for treeSeqCoalesced() for further discussion. The runCrosschecks parameter controls whether cross-checks between SLiM\u2019s internal data structures and the tree-sequence recording data structures will be conducted.\u00a0 These two sets of data structures record much the same thing (mutations in haplosomes), but using completely different representations, so such cross-checks can be useful to confirm that the two data structures do indeed represent the same conceptual state.\u00a0 This slows down the model considerably, however, and would normally be turned on only for debugging purposes, so it is turned off by default. The retainCoalescentOnly parameter controls how, exactly, simplification of the tree-sequence data is performed in SLiM (both for auto-simplification and for calls to treeSeqSimplify()).\u00a0 More specifically, this parameter controls the behavior of simplification for individuals and haplosomes that have been \u201cretained\u201d by calling treeSeqRememberIndividuals() with the parameter permanent=F.\u00a0 The default of retainCoalescentOnly=T helps to keep the number of retained individuals relatively small, which is helpful if your simulation regularly flags many individuals for retaining.\u00a0 In this case, changing retainCoalescentOnly to F may dramatically increase memory usage and runtime, in a similar way to permanently remembering all the individuals.\u00a0 See the documentation of treeSeqRememberIndividuals() for further discussion. The timeUnit parameter controls the time unit stated in the tree sequence when it is saved (which can be accessed through tskit APIs); it has no effect on the running simulation whatsoever.\u00a0 The default value, NULL, means that a time unit of \"ticks\" will be used for all model types.\u00a0 (In SLiM 3.7 / 3.7.1, NULL implied a time unit of \"generations\" for WF models, but \"ticks\" for nonWF models; given the new multispecies timescale parameters in SLiM 4, a default of \"ticks\" makes sense in all cases since now even in WF models one tick might not equal one biological generation.)\u00a0 It may be helpful to set timeUnit to \"generations\" explicitly when modeling non-overlapping generations in which one tick equals one generation, to tell tskit that the time unit does in fact represent biological generations; doing so may avoid warnings from tskit or msprime regarding the time unit, in cases such as recapitation where the simulation timescale is important."
        }
    },
    "Nucleotide utilities": {
        "codonsToAminoAcids": {
            "signatures": [
                "(is)codonsToAminoAcids(integer\u00a0codons, [li$\u00a0long\u00a0=\u00a0F], [logical$\u00a0paste\u00a0=\u00a0T])"
            ],
            "description": "Returns the amino acid sequence corresponding to the codon sequence in codons.\u00a0 Codons should be represented with values in [0, 63] where AAA is 0, AAC is 1, AAG is 2, and TTT is 63; see ancestralNucleotides() for discussion of this encoding.\u00a0 If long is F (the default), the standard single-letter codes for amino acids will be used (where Serine is \"S\", etc.); if long is T, the standard three-letter codes will be used instead (where Serine is \"Ser\", etc.).\u00a0 Beginning in SLiM 3.5, if long is 0, integer codes will be used as follows (and paste will be ignored): There does not seem to be a widely used standard for integer coding of amino acids, so SLiM just numbers them alphabetically, making stop codons 0.\u00a0 If you want a different coding, you can make your own 64-element vector and use it to convert codons to whatever integer codes you need.\u00a0 Other integer values of long are reserved for future use (to support other codings), and will currently produce an error. When long is T or F and paste is T (the default), the amino acid sequence returned will be a singleton string, such as \"LYATI\" (when long is F) or \"Leu-Tyr-Ala-Thr-Ile\" (when long is T).\u00a0 When long is T or F and paste is F, the amino acid sequence will instead be returned as a string vector, with one element per amino acid, such as \"L\" \"Y\" \"A\" \"T\" \"I\" (when long is F) or \"Leu\" \"Tyr\" \"Ala\" \"Thr\" \"Ile\" (when long is T).\u00a0 Using the paste=T option is considerably faster than using paste() in script. This function interprets the supplied codon sequence as the sense strand (i.e., the strand that is not transcribed, and which mirrors the mRNA\u2019s sequence).\u00a0 This uses the standard DNA codon table directly.\u00a0 For example, if the nucleotide sequence is CAA TTC, that will correspond to a codon vector of 16 61, and will result in the amino acid sequence Gln-Phe (\"QF\")."
        },
        "codonsToNucleotides": {
            "signatures": [
                "(is)codonsToNucleotides(integer\u00a0codons, [string$\u00a0format\u00a0=\u00a0\"string\"])"
            ],
            "description": "Returns the nucleotide sequence corresponding to the codon sequence supplied in codons.\u00a0 Codons should be represented with values in [0, 63] where AAA is 0, AAC is 1, AAG is 2, and TTT is 63; see ancestralNucleotides() for discussion of this encoding. The format parameter controls the format of the returned sequence.\u00a0 It may be \"string\" to obtain the sequence as a singleton string (e.g., \"TATACG\"), \"char\" to obtain it as a string vector of single characters (e.g., \"T\", \"A\", \"T\", \"A\", \"C\", \"G\"), or \"integer\" to obtain it as an integer vector (e.g., 3, 0, 3, 0, 1, 2), using SLiM\u2019s standard code of A=0, C=1, G=2, T=3."
        },
        "mm16To256": {
            "signatures": [
                "(float)mm16To256(float\u00a0mutationMatrix16)"
            ],
            "description": "Returns a 64\u00d74 mutation matrix that is functionally identical to the supplied 4\u00d74 mutation matrix in mutationMatrix16.\u00a0 The mutation rate for each of the 64 trinucleotides will depend only upon the central nucleotide of the trinucleotide, and will be taken from the corresponding entry for the same nucleotide in mutationMatrix16.\u00a0 This function can be used to easily construct a simple trinucleotide-based mutation matrix which can then be modified so that specific trinucleotides sustain a mutation rate that does not depend only upon their central nucleotide. See the documentation for initializeGenomicElementType() for further discussion of how these 64\u00d74 mutation matrices are interpreted and used."
        },
        "mmJukesCantor": {
            "signatures": [
                "(float)mmJukesCantor(float$\u00a0alpha)"
            ],
            "description": "Returns a mutation matrix representing a Jukes\u2013Cantor (1969) model with mutation rate alpha to each possible alternative nucleotide at a site.\u00a0 This 2\u00d72 matrix is suitable for use with initializeGenomicElementType().\u00a0 Note that the actual mutation rate produced by this matrix is 3*alpha."
        },
        "mmKimura": {
            "signatures": [
                "(float)mmKimura(float$\u00a0alpha, float$\u00a0beta)"
            ],
            "description": "Returns a mutation matrix representing a Kimura (1980) model with transition rate alpha and transversion rate beta.\u00a0 This 2\u00d72 matrix is suitable for use with initializeGenomicElementType().\u00a0 Note that the actual mutation rate produced by this model is alpha+2*beta."
        },
        "nucleotideCounts": {
            "signatures": [
                "(integer)nucleotideCounts(is\u00a0sequence)"
            ],
            "description": "A convenience function that returns an integer vector of length four, providing the number of occurrences of A / C / G / T nucleotides, respectively, in the supplied nucleotide sequence.\u00a0 The parameter sequence may be a singleton string (e.g., \"TATA\"), a string vector of single characters (e.g., \"T\", \"A\", \"T\", \"A\"), or an integer vector (e.g., 3, 0, 3, 0), using SLiM\u2019s standard code of A=0, C=1, G=2, T=3."
        },
        "nucleotideFrequencies": {
            "signatures": [
                "(float)nucleotideFrequencies(is\u00a0sequence)"
            ],
            "description": "A convenience function that returns a float vector of length four, providing the frequencies of occurrences of A / C / G / T nucleotides, respectively, in the supplied nucleotide sequence.\u00a0 The parameter sequence may be a singleton string (e.g., \"TATA\"), a string vector of single characters (e.g., \"T\", \"A\", \"T\", \"A\"), or an integer vector (e.g., 3, 0, 3, 0), using SLiM\u2019s standard code of A=0, C=1, G=2, T=3."
        },
        "nucleotidesToCodons": {
            "signatures": [
                "(integer)nucleotidesToCodons(is\u00a0sequence)"
            ],
            "description": "Returns the codon sequence corresponding to the nucleotide sequence in sequence.\u00a0 The codon sequence is an integer vector with values from 0 to 63, based upon successive nucleotide triplets in the nucleotide sequence.\u00a0 The codon value for a given nucleotide triplet XYZ is 16X\u00a0+\u00a04Y\u00a0+\u00a0Z, where X, Y, and Z have the usual values A=0, C=1, G=2, T=3.\u00a0 For example, the triplet AAA has a codon value of 0, AAC is 1, AAG is 2, AAT is 3, ACA is 4, and on upward to TTT which is 63.\u00a0 If the nucleotide sequence AACACATTT is passed in, the codon vector 1 4 63 will therefore be returned.\u00a0 These codon values can be useful in themselves; they can also be passed to codonsToAminoAcids() to translate them into the corresponding amino acid sequence if desired. The nucleotide sequence in sequence may be supplied in any of three formats: a string vector with single-letter nucleotides (e.g., \"T\", \"A\", \"T\", \"A\"), a singleton string of nucleotide letters (e.g., \"TATA\"), or an integer vector of nucleotide values (e.g., 3, 0, 3, 0) using SLiM\u2019s standard code of A=0, C=1, G=2, T=3.\u00a0 If the choice of format is not driven by other considerations, such as ease of manipulation, then the singleton string format will certainly be the most memory-efficient for long sequences, and will probably also be the fastest.\u00a0 The nucleotide sequence provided must be a multiple of three in length, so that it translates to an integral number of codons."
        },
        "randomNucleotides": {
            "signatures": [
                "(is)randomNucleotides(integer$\u00a0length, [Nif\u00a0basis\u00a0=\u00a0NULL], [string$\u00a0format\u00a0=\u00a0\"string\"])"
            ],
            "description": "Generates a new random nucleotide sequence with length bases.\u00a0 The four nucleotides ACGT are equally probable if basis is NULL (the default); otherwise, basis may be a 4-element integer or float vector providing relative fractions for A, C, G, and T respectively (these need not sum to 1.0, as they will be normalized).\u00a0 More complex generative models such as Markov processes are not supported intrinsically in SLiM at this time, but arbitrary generated sequences may always be loaded from files on disk. The format parameter controls the format of the returned sequence.\u00a0 It may be \"string\" to obtain the generated sequence as a singleton string (e.g., \"TATA\"), \"char\" to obtain it as a string vector of single characters (e.g., \"T\", \"A\", \"T\", \"A\"), or \"integer\" to obtain it as an integer vector (e.g., 3, 0, 3, 0), using SLiM\u2019s standard code of A=0, C=1, G=2, T=3.\u00a0 For passing directly to initializeAncestralNucleotides(), format \"string\" (a singleton string) will certainly be the most memory-efficient, and probably also the fastest.\u00a0 Memory efficiency can be a significant consideration; the nucleotide sequence for a chromosome of length 109 will occupy approximately 1 GB of memory when stored as a singleton string (with one byte per nucleotide), and much more if stored in the other formats.\u00a0 However, the other formats can be easier to work with in Eidos, and so may be preferable for relatively short chromosomes if you are manipulating the generated sequence."
        }
    },
    "Population genetics utilities": {
        "calcDxy": {
            "signatures": [
                "(float$)calcDxy(object<Haplosome>\u00a0haplosomes1, object<Haplosome>\u00a0haplosomes2, [No<Mutation>\u00a0muts\u00a0=\u00a0NULL], [Ni$\u00a0start\u00a0=\u00a0NULL], [Ni$\u00a0end\u00a0=\u00a0NULL], [logical$\u00a0normalize\u00a0=\u00a0F])"
            ],
            "description": "Calculates the estimated Dxy between two Haplosome vectors for the set of mutations given in muts.\u00a0 Dxy is the expected number of differences between two sequences, typically drawn from two different subpopulations whose haplosomes are given in haplosomes1 and haplosomes2.\u00a0 It is therefore a metric of genetic divergence, comparable in some respects to FST; see Cruickshank and Hahn (2014, Molecular Ecology) for a discussion of FST versus Dxy.\u00a0 This method implements Dxy as defined by Nei (1987) in Molecular Evolutionary Genomics (eq. 10.20), with optimizations for computational efficiency based upon an assumption that that multiallelic loci are rare (this is compatible with the infinite-sites model). The calculation can be narrowed to apply to only a window \u2013 a subrange of the full haplosomes \u2013 by passing the interval bounds [start, end] for the desired window.\u00a0 In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.\u00a0 The default behavior, with start and end of NULL, provides the haplosome-wide Dxy. If normalize is F (the default), the returned float value is simply the expected number of differences, following Nei.\u00a0 Often, however, it will be desirable to normalize that value by dividing by the length of the sequence considered, yielding the expected number of differences per site, a metric that then does not depend upon the sequence length; passing normalize=T will return that normalized value, and that is probably what most users of this function will want. The implementation of calcDxy(), viewable with functionSource(), treats every mutation in muts as independent in its calculations (similar to calcPi()); in other words, if mutations are stacked, the Dxy value calculated is by mutation, not by site.\u00a0 Similarly, if multiple Mutation objects exist in different haplosomes at the same site (whether representing different genetic states, or multiple mutational lineages for the same genetic state), each Mutation object is treated separately for purposes of the calculation, just as if they were at different sites.\u00a0 One could regard these choices as embodying an infinite-sites interpretation of the segregating mutations.\u00a0 In most biologically realistic models, such genetic states will be quite rare, and so the impact of these choices will be negligible; however, in some models these distinctions may be important.\u00a0 See calcPairHeterozygosity() for further discussion. All haplosomes and mutations must be associated with the same chromosome.\u00a0 If muts is NULL (the default), all mutations in the population associated with the same chromosome as the given haplosomes will be used. This function was written by Vitor Sudbrack (currently affiliated with University of Lausanne)."
        },
        "calcFST": {
            "signatures": [
                "(float$)calcFST(object<Haplosome>\u00a0haplosomes1, object<Haplosome>\u00a0haplosomes2, [No<Mutation>\u00a0muts\u00a0=\u00a0NULL], [Ni$\u00a0start\u00a0=\u00a0NULL], [Ni$\u00a0end\u00a0=\u00a0NULL])"
            ],
            "description": "Calculates the FST between two Haplosome vectors \u2013 typically, but not necessarily, the haplosomes that constitute two different subpopulations (which we will assume for the purposes of this discussion).\u00a0 In general, higher FST indicates greater genetic divergence between subpopulations.\u00a0 The haplosomes may be associated with more than one chromosome, in a multi-chromosome model; if so, haplosomes1 and haplosomes2 must be associated with the same set of chromosomes, defining the focal set of chromosomes for the calculation. The calculation is done using only the mutations in muts; if muts is NULL, all mutations associated with the focal chromosomes are used.\u00a0 The muts parameter can be used to calculate the FST only for a particular mutation type (by passing only mutations of that type), for example; it can focus the calculation on particular mutations of interest.\u00a0 The mutations in muts must always be associated with the focal chromosomes. If there is a single focal chromosome, the calculation can be narrowed to apply to only a window \u2013 a subrange of the focal chromosome \u2013 by passing the interval bounds [start, end] for the desired window.\u00a0 In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.\u00a0 The default behavior, with start and end of NULL, provides the chromosome-wide FST, which is often used to assess the overall level of genetic divergence between sister species or allopatric subpopulations. The code for calcFST() is, roughly, an Eidos implementation of Wright\u2019s definition of FST (but see below for further discussion and clarification): FST = 1 - HS / HT where HS is the average heterozygosity in the two subpopulations, and HT is the total heterozygosity when both subpopulations are combined.\u00a0 In this implementation, the two haplosome vectors are weighted equally, not weighted by their size.\u00a0 In SLiM 3, the implementation followed Wright\u2019s definition closely, and returned the average of ratios: mean(1.0 - H_s/H_t), in the Eidos code.\u00a0 In SLiM 4, it returns the ratio of averages instead: 1.0 - mean(H_s)/mean(H_t).\u00a0 In other words, the FST value reported by SLiM 4 is an average across the specified mutations in the two sets of haplosomes, where H_s and H_t are first averaged across all specified mutations prior to taking the ratio of the two.\u00a0 This ratio of averages is less biased than the average of ratios, and and is generally considered to be best practice (see, e.g., Bhatia et al., 2013).\u00a0 This means that the behavior of calcFST() differs between SLiM 3 and SLiM 4. As can be seen from its equation, the FST is undefined if HT is zero, which occurs if no mutations are present in the haplosomes provided (given the optionally specified window and set of mutations).\u00a0 In that case, calcFST() will return NAN.\u00a0 It is up to the caller to detect this with isNAN() and handle it as necessary. The implementation of calcFST(), viewable with functionSource(), treats every mutation in muts as independent in the heterozygosity calculations; in other words, if mutations are stacked, the heterozygosity calculated is by mutation, not by site.\u00a0 Similarly, if multiple Mutation objects exist in different haplosomes at the same site (whether representing different genetic states, or multiple mutational lineages for the same genetic state), each Mutation object is treated separately for purposes of the heterozygosity calculation, just as if they were at different sites.\u00a0 One could regard these choices as embodying an infinite-sites interpretation of the segregating mutations.\u00a0 In most biologically realistic models, such genetic states will be quite rare, and so the impact of these choices will be negligible; however, in some models these distinctions may be important."
        },
        "calcHeterozygosity": {
            "signatures": [
                "(float$)calcHeterozygosity(object<Haplosome>\u00a0haplosomes, [No<Mutation>\u00a0muts\u00a0=\u00a0NULL], [Ni$\u00a0start\u00a0=\u00a0NULL], [Ni$\u00a0end\u00a0=\u00a0NULL])"
            ],
            "description": "Calculates the heterozygosity for a vector of haplosomes (containing at least one element), based upon the frequencies of mutations in the haplosomes.\u00a0 The result is the expected heterozygosity, for the individuals to which the haplosomes belong, assuming that they are under Hardy-Weinberg equilibrium; this can be compared to the observed heterozygosity of an individual, as calculated by calcPairHeterozygosity().\u00a0 Often haplosomes will be all of the haplosomes in a subpopulation, or in the entire population, but any haplosome vector may be used.\u00a0 By default, with muts=NULL, the calculation is based upon all mutations in the simulation; the calculation can instead be based upon a subset of mutations, such as mutations of a specific mutation type, by passing the desired vector of mutations for muts. In multi-chromosome models, all of the haplosomes and mutations passed in haplosomes and muts must all be associated with the same single chromosome.\u00a0 If you wish to calculate heterozygosity across multiple chromosomes, you can simply write a for loop that calculates it for each chromosome and combines the results; but it is not entirely clear how to weight the chromosomes to produce a single number, especially when sex chromosomes and other chromosomes of variable ploidy might be represented in haplosomes, so it is not done automatically by this function. The calculation can be narrowed to apply to only a window \u2013 a subrange of the full chromosome \u2013 by passing the interval bounds [start, end] for the desired window.\u00a0 In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.\u00a0 The default behavior, with start and end of NULL, provides the haplosome-wide heterozygosity. The implementation of calcHeterozygosity(), viewable with functionSource(), treats every mutation as independent in the heterozygosity calculations.\u00a0 One could regard this choice as embodying an infinite-sites interpretation of the segregating mutations.\u00a0 In most biologically realistic models, such genetic states will be quite rare, and so the impact of this choice will be negligible; however, in some models this distinction may be important.\u00a0 See calcPairHeterozygosity() for further discussion."
        },
        "calcInbreedingLoad": {
            "signatures": [
                "(float$)calcInbreedingLoad(object<Haplosome>\u00a0haplosomes, [Nio<MutationType>$\u00a0mutType\u00a0=\u00a0NULL])"
            ],
            "description": "Calculates inbreeding load (the haploid number of lethal equivalents, or B) for a vector of haplosomes (containing at least one element) passed in haplosomes.\u00a0 The calculation can be limited to a focal mutation type passed in mutType (which may be either an integer representing the ID of the desired mutation type, or a MutationType object specified directly); if mutType is NULL (the default), all of the mutations for the focal species will be considered.\u00a0 In any case, only deleterious mutations (those with a negative selection coefficient) will be included in the final calculation. The inbreeding load is a measure of the quantity of recessive deleterious variation that is heterozygous in a population and can contribute to fitness declines under inbreeding.\u00a0 This function implements the following equation from Morton et al. (1956), which assumes no epistasis and random mating: where q is the frequency of a given deleterious allele, s is the absolute value of the selection coefficient, and h is its dominance coefficient.\u00a0 Note that the implementation, viewable with functionSource(), sets a maximum |s| of 1.0 (i.e., a lethal allele); |s| can sometimes be greater than 1.0 when s is drawn from a distribution, but in practice an allele with s\u00a0<\u00a0-1.0 has the same lethal effect as when s\u00a0=\u00a0-1.0.\u00a0 Also note that this implementation will not work when the model changes the dominance coefficients of mutations using mutationEffect() callbacks, since it relies on the dominanceCoeff property of MutationType. Finally, note that, to estimate the diploid number of lethal equivalents (2B), the result from this function can simply be multiplied by two. This function was contributed by Chris Kyriazis; thanks, Chris!"
        },
        "calcLD_D": {
            "signatures": [
                "(float)calcLD_D(object<Mutation>$\u00a0mut1, [No<Mutation>\u00a0mut2\u00a0=\u00a0NULL], [No<Haplosome>\u00a0haplosomes\u00a0=\u00a0NULL])"
            ],
            "description": "Calculates the linkage disequilibrium (LD) coefficient D between a focal mutation mut1 and one or more mutations in mut2, evaluated across a set of haplosomes given by haplosomes.\u00a0 The result is a float vector that matches the size and order of mut2.\u00a0 The implementation of this function, viewable with functionSource(), calculates D as defined by Hill and Robertson (1968, p. 226).\u00a0 The coefficient D is within [\u2212p(1\u2212p), p(1\u2212p)], where p is the frequency of the more common mutation (that is, p\u00a0=\u00a0max(f1, f2) where f1 and f2 are the frequencies of the two mutations for which D is being calculated); for the normalized LD metric r2, which is within [0, 1], see calcLD_Rsquared().\u00a0 Departures of D from zero indicate LD; more specifically, D\u00a0>\u00a00 indicates that the mutations occur together more often than expected by chance (positive linkage), whereas D\u00a0<\u00a00 indicates they occur together less often than expected by chance (negative linkage). All mutations in mut2 must be associated with the same chromosome as mut1; this function does not currently calculate LD between mutations associated with different chromosomes.\u00a0 If mut2 is NULL (the default), all such mutations in the population (including mut1 itself) will be used.\u00a0 Similarly, all haplosomes must be associated with the same chromosome as mut1.\u00a0 If the haplosomes parameter is NULL (the default), all such haplosomes in the population will be used. This function was written by Vitor Sudbrack (currently affiliated with University of Lausanne)."
        },
        "calcLD_Rsquared": {
            "signatures": [
                "(float)calcLD_Rsquared(object<Mutation>$\u00a0mut1, [No<Mutation>\u00a0mut2\u00a0=\u00a0NULL], [No<Haplosome>\u00a0haplosomes\u00a0=\u00a0NULL], [logical$\u00a0squared\u00a0=\u00a0T])"
            ],
            "description": "Calculates the linkage disequilibrium (LD) squared correlation coefficient r2 between a focal mutation mut1 and one or more mutations in mut2, evaluated across a set of haplosomes given by haplosomes.\u00a0 The result is a float vector that matches the size and order of mut2.\u00a0 The implementation of this function, viewable with functionSource(), calculates r2 as defined by Hill and Robertson (1968, p. 227).\u00a0 The squared correlation coefficient r2 is a normalized measure of LD within [0, 1] (for the unnormalized LD coefficient D, see calcLD_D()).\u00a0 When r2\u00a0=\u00a00, there is no statistical association between the mutations; they co-occur as expected by chance.\u00a0 A value of r2\u00a0=\u00a01 indicates complete correlation: the mutations either always appear together or never appear together, depending on the sign of the underlying correlation coefficient r.\u00a0 To obtain the raw (signed) r value instead of r2, you can pass squared=F instead of the default of T. All mutations in mut2 must be associated with the same chromosome as mut1; this function does not currently calculate LD between mutations associated with different chromosomes.\u00a0 If mut2 is NULL (the default), all such mutations in the population (including mut1 itself) will be used.\u00a0 Similarly, all haplosomes must be associated with the same chromosome as mut1.\u00a0 If the haplosomes parameter is NULL (the default), all such haplosomes in the population will be used. This function was written by Vitor Sudbrack (currently affiliated with University of Lausanne)."
        },
        "calcMeanFroh": {
            "signatures": [
                "(float$)calcMeanFroh(object<Individual>\u00a0individuals, [integer$\u00a0minimumLength\u00a0=\u00a01000000], [Niso<Chromosome>$\u00a0chromosome\u00a0=\u00a0NULL])"
            ],
            "description": "Calculates the mean value of the Froh statistic across the individuals passed in individuals.\u00a0 This statistic is a measure of individual autozygosity, likely resulting from inbreeding, and is calculated based upon \u201cruns of homozygosity\u201d, or ROH, in the genome of an individual.\u00a0 Broadly speaking, Froh is the proportion of an individual\u2019s genome that is spanned by ROH longer than a given threshold length.\u00a0 However, it should be noted that there are many different ways of calculating Froh, producing different results.\u00a0 For example, the threshold length might be a given constant, or might be determined statistically from the characteristics of the population.\u00a0 Furthermore, some heterozygous sites might be discarded (to compensate for genotyping errors), a minimum SNP density might be required within a sliding window for an ROH to be diagnosed, and so forth \u2013 it can get quite complex, as seen in the software PLINK (Purcell et al., 2007) and GARLIC (Szpiech, Blant and Pemberton, 2017).\u00a0 The method used by calcMeanFroh() is the simplest possible method, assessing ROH for each individual directly from the simulated mutations without filtering or modification, and applying a given constant threshold length.\u00a0 If a more sophisticated Froh algorithm is desired, one could modify the implementation of calcMeanFroh(), which is viewable with functionSource(), or one could output VCF data from SLiM and analyze it with other tools, perhaps calling out from the running SLiM script with system(). The threshold ROH length used by calcMeanFroh() is supplied by the parameter minimumLength.\u00a0 It defaults to 1e6, or 1 Mbp, since that is a length commonly used in the literature, but can be adjusted as desired. The chromosome parameter can be supplied to focus the Froh calculation on a specific chromosome; otherwise, the calculation spans all chromosomes for which the individual is actually diploid (without a null haplosome).\u00a0 If Froh cannot be calculated for an individual (due to the presence of null haplosomes for every intrinsically diploid chromosome being analyzed), that individual is omitted from the mean Froh calculation; for example, if an X chromosome is the focal chromosome being analyzed, all males will be omitted from the mean Froh calculation.\u00a0 If all individuals are omitted from the mean Froh calculation for this reason, NAN is returned. This function was developed with advice from Ryan Chaffee.\u00a0 Thanks, Ryan!"
        },
        "calcPairHeterozygosity": {
            "signatures": [
                "(float$)calcPairHeterozygosity(object<Haplosome>$\u00a0haplosome1, object<Haplosome>$\u00a0haplosome2, [Ni$\u00a0start\u00a0=\u00a0NULL], [Ni$\u00a0end\u00a0=\u00a0NULL], [logical$\u00a0infiniteSites\u00a0=\u00a0T])"
            ],
            "description": "Calculates the heterozygosity for a pair of haplosomes; these will typically be two homologous haplosomes of the same diploid individual, but any two haplosomes associated with the same chromosome may be supplied. The calculation can be narrowed to apply to only a window \u2013 a subrange of the full chromosome \u2013 by passing the interval bounds [start, end] for the desired window.\u00a0 In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.\u00a0 The default behavior, with start and end of NULL, provides the haplosome-wide heterozygosity. The implementation calcPairHeterozygosity(), viewable with functionSource(), treats every mutation as independent in the heterozygosity calculations by default (i.e., with infiniteSites=T).\u00a0 If mutations are stacked, the heterozygosity calculated therefore depends upon the number of unshared mutations, not the number of differing sites.\u00a0 Similarly, if multiple Mutation objects exist in different haplosomes at the same site (whether representing different genetic states, or multiple mutational lineages for the same genetic state), each Mutation object is treated separately for purposes of the heterozygosity calculation, just as if they were at different sites.\u00a0 One could regard these choices as embodying an infinite-sites interpretation of the segregating mutations.\u00a0 In most biologically realistic models, such genetic states will be quite rare, and so the impact of this choice will be negligible; however, in some models this distinction may be important.\u00a0 The behavior of calcPairHeterozygosity() can be switched to calculate based upon the number of differing sites, rather than the number of unshared mutations, by passing infiniteSites=F."
        },
        "calcPi": {
            "signatures": [
                "(float$)calcPi(object<Haplosome>\u00a0haplosomes, [No<Mutation>\u00a0muts\u00a0=\u00a0NULL], [Ni$\u00a0start\u00a0=\u00a0NULL], [Ni$\u00a0end\u00a0=\u00a0NULL])"
            ],
            "description": "Calculates \u03c0 (nucleotide diversity, a metric of genetic diversity) for a vector of haplosomes (containing at least two elements), based upon the mutations in the haplosomes.\u00a0 \u03c0 is computed by calculating the mean number of pairwise differences at each site, summing across all sites, and dividing by the number of sites.\u00a0 Therefore, it is interpretable as the number of differences per site expected between two randomly chosen sequences.\u00a0 The mathematical formulation (as an estimator of the population parameter \u03b8) is based on work in Nei and Li (1979), Nei and Tajima (1981), and Tajima (1983; equation A3).\u00a0 The exact formula used here is common in textbooks (e.g., equations 9.1\u20139.5 in Li 1997, equation 3.3 in Hahn 2018, or equation 2.2 in Coop 2020). Often haplosomes will be all of the haplosomes in a subpopulation, or in the entire population, but any haplosome vector may be used.\u00a0 By default, with muts=NULL, the calculation is based upon all mutations in the simulation; the calculation can instead be based upon a subset of mutations, such as mutations of a specific mutation type, by passing the desired vector of mutations for muts. The calculation can be narrowed to apply to only a window \u2013 a subrange of the full chromosome \u2013 by passing the interval bounds [start, end] for the desired window.\u00a0 In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.\u00a0 The default behavior, with start and end of NULL, provides the haplosome-wide value of \u03c0. The implementation of calcPi(), viewable with functionSource(), treats every mutation as independent in the heterozygosity calculations.\u00a0 One could regard this choice as embodying an infinite-sites interpretation of the segregating mutations, as with calcHeterozygosity().\u00a0 Indeed, finite-sites models of \u03c0 have been derived (Tajima 1996) though are not used here.\u00a0 In most biologically realistic models, such genetic states will be quite rare, and so the impact of this assumption will be negligible; however, in some models this distinction may be important.\u00a0 See calcPairHeterozygosity() for further discussion.\u00a0 This function was written by Nick Bailey (currently affiliated with CNRS and the Laboratory of Biometry and Evolutionary Biology at University Lyon 1), with helpful input from Peter Ralph and Chase Nelson."
        },
        "calcSFS": {
            "signatures": [
                "(numeric)calcSFS([Ni$\u00a0binCount\u00a0=\u00a0NULL], [No<Haplosome>\u00a0haplosomes\u00a0=\u00a0NULL], [No<Mutation>\u00a0muts\u00a0=\u00a0NULL], [string$\u00a0metric\u00a0=\u00a0\"density\"], [logical$\u00a0fold\u00a0=\u00a0F])"
            ],
            "description": "Calculates the site frequency spectrum, or SFS, for the mutations specified by muts, within the haplosomes specified by haplosomes.\u00a0 The site frequency spectrum or SFS (sometimes called the allele frequency spectrum, although some authors distinguish between the two) is essentially a histogram of the frequencies of the mutations within the haplosomes; the first bin spans the lowest range of frequencies (down to a frequency of 0.0, or a count of 1), whereas the last bin spans the highest range of frequencies (up to a frequency of 1.0, or a count equal to number of haplosomes minus one).\u00a0 The idea was introduced by Watterson (1975), and will be discussed in any population genetics textbook (e.g., A. Cutter, 2019, pp. 50\u201352).\u00a0 This histogram can be returned as a float vector of density values for each bin by specifying \"density\" for metric (the default), or as an integer vector of count values for each bin by specifying \"count\". There are two modes of operation for calcSFS().\u00a0 If a specific number of bins is passed for binCount, then the frequency range [0.0, 1.0] is subdivided into binCount intervals of equal width, and the mutations are tallied into those bins according to their frequencies within the haplosomes to produce the histogram.\u00a0 In this mode, there will be exactly binCount elements in the returned vector.\u00a0 Note that either \"density\" or \"count\" can be chosen in this mode; you can return the frequency bin tallies as either densities or counts. In the other mode of operation, chosen with a binCount value of NULL, the bins instead represent the count of the number of occurrences for each mutation, and range from a count of 1 (the bin for mutations that occur only once in the haplosomes, sometimes called \u201csingletons\u201d) up to a count of N-1 where N is the number of haplosomes.\u00a0 (Note that mutations occurring in all N haplosomes are not included in the tally, since they would not be empirically observable.)\u00a0 In this mode, there will be exactly N-1 elements in the returned vector.\u00a0 Again, either \"density\" or \"count\" can be chosen in this mode; you can return the count bin tallies as either densities or counts (it\u2019s a bit confusing, but we\u2019re talking about two different kinds of \u201ccounts\u201d, the count of the number of times a mutation occurs in the haplosomes versus the count of the number of mutations that were tallied into a particular count bin). The haplosomes parameter can be either a vector of Haplosome objects or NULL.\u00a0 If NULL is passed, calcSFS() will calculate the SFS across the whole species, using all non-null haplosomes present (and thus there must be only a single species in the model, since an SFS cannot be calculated across multiple species).\u00a0 Otherwise, haplosomes can contain any set of haplosomes desired, such as from the individuals of one subpopulation, several subpopulations, or an entire species.\u00a0 However, they must all belong to the same species, and null haplosomes will be automatically and silently excluded from the set. The muts parameter can be either a vector of Mutation objects or NULL.\u00a0 If NULL is passed, calcSFS() will calculate the SFS across all mutations belonging to the focal species (as determined from the species of the haplosomes).\u00a0 Otherwise, muts can contain any set of mutations desired, such as mutations belonging to a specific mutation type, mutations within a specific range of positions along the chromosome, or all of the mutations in the focal species. The binCount and metric parameters have already been discussed.\u00a0 Finally, the fold parameter, if T, \u201cfolds\u201d the calculated SFS, adding the first and last bins, the second and next-to-last bins, etc., until the center is reached.\u00a0 Folding is common when working with empirical data, where one often doesn\u2019t know the \u201cpolarity\u201d \u2013 which allele at a site is ancestral and which is derived.\u00a0 Folding solves this problem, because the polarity then doesn\u2019t matter; the tally for a given mutation ends up in the same bin regardless.\u00a0 If the number of bins is even, folding can be performed without ambiguity; the final number of bins is exactly half the original number of bins, and each final bin is the sum of two original bins.\u00a0 If the number of bins is odd, the correct treatment of the central bin is somewhat ambiguous.\u00a0 In calcFST(), the central bin is added to itself \u2013 doubled \u2013 and the number of bins is equal to half the original number of bins rounded up.\u00a0 If you would prefer to exclude the central bin altogether \u2013 another population treatment \u2013 then when the original number of bins is odd, you can simply discard the final value in the returned vector (and, if you wish to work with densities rather than counts, re-normalize the result to sum to 1.0). The implementation of calcSFS(), viewable with functionSource(), tallies each mutation separately, even if more than one mutation occurs at the same position (or is even stacked with another mutation).\u00a0 One could regard this choice as embodying an infinite-sites interpretation of the SFS, perhaps; in any case, it follows SLiM\u2019s behavior in other population-genetics utility functions.\u00a0 In most biologically realistic models, such genetic states will be quite rare, and so the impact of this assumption will be negligible; however, in some models this distinction may be important. This function is compatible with multi-chromosome models, in the following sense.\u00a0 When binCount is specified with an integer value, mutations are binned according to their frequencies, as described above.\u00a0 In a multi-chromosome model, the haplosomes and mutations used by calcSFS() may be associated with more than one chromosome, and the frequency assessed for each mutation is its frequency specifically within the haplosomes associated with its chromosome (as you would expect).\u00a0 Mutations occurring in different chromosomes can therefore be tallied together into the same frequency bins, and combined into a single SFS; this produces a meaningful SFS.\u00a0 (If you want an SFS for just a single chromosome, then of course you can pass just those haplosomes and mutations to calcSFS().)\u00a0 When binCount is NULL, on the other hand, mutations are binned according to their counts, as described above.\u00a0 In a multi-chromosome model, it would not make sense to bin counts together from different chromosomes, since those counts might not be on the same scale \u2013 the number of haplosomes associated with the various chromosomes might not be equal.\u00a0 In this case, calcSFS() will raise an error if haplosomes from more than one chromosome are supplied, or if haplosomes is NULL (since it doesn\u2019t know which chromosome to choose).\u00a0 If you wish to tally according to counts, with binCount=NULL, you must pass in a vector of haplosomes associated with a single chromosome.\u00a0 (If you know what you are doing and wish to combine counts across multiple chromosomes, you can simply call calcSFS() once per chromosome, and combine the resulting vectors by adding them together.) Thanks to Ryan Chaffee and Chase Nelson for helpful input."
        },
        "calcTajimasD": {
            "signatures": [
                "(float$)calcTajimasD(object<Haplosome>\u00a0haplosomes, [No<Mutation>\u00a0muts\u00a0=\u00a0NULL], [Ni$\u00a0start\u00a0=\u00a0NULL], [Ni$\u00a0end\u00a0=\u00a0NULL])"
            ],
            "description": "Calculates Tajima\u2019s D (a test of neutrality based on the allele frequency spectrum) for a vector of haplosomes (containing at least four elements), based upon the mutations in the haplosomes.\u00a0 The mathematical formulation is given in Tajima 1989 (equation 38) and remains unchanged (e.g., equations 2.30 in Durrett 2008, 8.4 in Hahn 2018, and 4.44 in Coop 2020).\u00a0 Often haplosomes will be all of the haplosomes in a subpopulation, or in the entire population, but any haplosome vector may be used.\u00a0 By default, with muts=NULL, the calculation is based upon all mutations in the simulation; the calculation can instead be based upon a subset of mutations, such as mutations of a specific mutation type, by passing the desired vector of mutations for muts. The calculation can be narrowed to apply to only a window \u2013 a subrange of the full chromosome \u2013 by passing the interval bounds [start, end] for the desired window.\u00a0 In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.\u00a0 The default behavior, with start and end of NULL, provides the haplosome-wide Tajima\u2019s D. If the genetic diversity contained within the haplosomes is insufficient for the calculation, calcTajimasD() may return NAN.\u00a0 It is up to the caller to detect this with isNAN() and handle it as necessary. The implementation of calcTajimasD(), viewable with functionSource(), treats every mutation as independent in the heterozygosity calculations.\u00a0 One could regard this choice as embodying an infinite-sites interpretation of the segregating mutations, as with calcHeterozygosity().\u00a0 Indeed, Tajima\u2019s D can be modified with finite-sites models of \u03c0 and \u03b8 (Misawa and Tajima 1997) though these are not used here.\u00a0 In most biologically realistic models, such genetic states will be quite rare, and so the impact of this assumption will be negligible; however, in some models this distinction may be important.\u00a0 See calcPairHeterozygosity() for further discussion.\u00a0 This function was written by Nick Bailey (currently affiliated with CNRS and the Laboratory of Biometry and Evolutionary Biology at University Lyon 1), with helpful input from Peter Ralph."
        },
        "calcVA": {
            "signatures": [
                "(float$)calcVA(object<Individual>\u00a0individuals, io<MutationType>$\u00a0mutType)"
            ],
            "description": "Calculates VA, the additive genetic variance, among a vector of individuals (containing at least two elements) passed in individuals, in a particular mutation type mutType that represents quantitative trait loci (QTLs) influencing a quantitative phenotypic trait.\u00a0 The mutType parameter may be either an integer representing the ID of the desired mutation type, or a MutationType object specified directly. This function assumes that mutations of type mutType encode their effect size upon the quantitative trait in their selectionCoeff property, as is fairly standard in SLiM.\u00a0 The implementation of calcVA(), which is viewable with functionSource(), is quite simple; if effect sizes are stored elsewhere (such as with setValue()), a new user-defined function following the pattern of calcVA() can easily be written."
        },
        "calcWattersonsTheta": {
            "signatures": [
                "(float$)calcWattersonsTheta(object<Haplosome>\u00a0haplosomes, [No<Mutation>\u00a0muts\u00a0=\u00a0NULL], [Ni$\u00a0start\u00a0=\u00a0NULL], [Ni$\u00a0end\u00a0=\u00a0NULL])"
            ],
            "description": "Calculates Watterson\u2019s theta (a metric of genetic diversity comparable to heterozygosity) for a vector of haplosomes (containing at least one element), based upon the mutations in the haplosomes.\u00a0 Often haplosomes will be all of the haplosomes in a subpopulation, or in the entire population, but any haplosome vector may be used.\u00a0 By default, with muts=NULL, the calculation is based upon all mutations in the simulation; the calculation can instead be based upon a subset of mutations, such as mutations of a specific mutation type, by passing the desired vector of mutations for muts. The calculation can be narrowed to apply to only a window \u2013 a subrange of the full chromosome \u2013 by passing the interval bounds [start, end] for the desired window.\u00a0 In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.\u00a0 The default behavior, with start and end of NULL, provides the haplosome-wide Watterson\u2019s theta. The implementation of calcWattersonsTheta(), viewable with functionSource(), treats every mutation as independent in the heterozygosity calculations.\u00a0 One could regard this choice as embodying an infinite-sites interpretation of the segregating mutations, as with calcHeterozygosity().\u00a0 In most biologically realistic models, such genetic states will be quite rare, and so the impact of this assumption will be negligible; however, in some models this distinction may be important.\u00a0 See calcPairHeterozygosity() for further discussion."
        }
    },
    "Other utilities": {
        "summarizeIndividuals": {
            "signatures": [
                "(float)summarizeIndividuals(object<Individual>\u00a0individuals, integer\u00a0dim, numeric\u00a0spatialBounds, string$\u00a0operation, [Nlif$\u00a0empty\u00a0=\u00a00.0], [logical$\u00a0perUnitArea\u00a0=\u00a0F], [Ns$\u00a0spatiality\u00a0=\u00a0NULL])"
            ],
            "description": "Returns a vector, matrix, or array that summarizes spatial patterns of information related to the individuals in individuals.\u00a0 In essence, those individuals are assigned into bins according to their spatial position, and then a summary value for each bin is calculated based upon the individuals each bin contains.\u00a0 The individuals might be binned in one dimension (resulting in a vector of summary values), in two dimensions (resulting in a matrix), or in three dimensions (resulting in an array).\u00a0 Typically the spatiality of the result (the dimensions into which the individuals are binned) will match the dimensionality of the model, as indicated by the default value of NULL for the optional spatiality parameter; for example, a two-dimensional (\"xy\") model would by default produce a two-dimensional matrix as a summary.\u00a0 However, a spatiality that is more restrictive than the model dimensionality may be passed; for example, in a two-dimensional (\"xy\") model a spatiality of \"y\" could be passed to summarize individuals into a vector, rather than a matrix, assigning them to bins based only upon their y position (i.e., the value of their y property).\u00a0 Whatever spatiality is chosen, the parameter dim provides the dimensions of the desired result, in the same form that the dim() function does: first the number of rows, then the number of columns, and then the number of planes, as needed (see the Eidos manual for discussion of matrices, arrays, and dim()).\u00a0 The length of dims must match the requested spatiality; for spatiality \"xy\", for example, dims might be c(50,100) to request that the returned matrix have 50 rows and 100 columns.\u00a0 The result vector/matrix/array is in the correct orientation to be directly usable as a spatial map, by passing it to the defineSpatialMap() method of Subpopulation.\u00a0 For further discussion of dimensionality and spatiality, see initializeInteractionType() and InteractionType. The spatialBounds parameter defines the spatial boundaries within which the individuals are binned.\u00a0 Typically this is the spatial bounds of a particular subpopulation, within which the individuals reside; for individuals in p1, for example, you would likely pass p1.spatialBounds for this.\u00a0 However, this is not required; individuals may come from any or all subpopulations in the model, and spatialBounds may be any bounds of non-zero area (if an individual falls outside of the given spatial bounds, it is excluded, as if it were not in individuals at all).\u00a0 If you have multiple subpopulations that conceptually reside within the same overall coordinate space, for example, that can be accommodated here.\u00a0 The bounds are supplied in the dimensionality of the model, in the same form as for Subpopulation; for an \"xy\" model, for example, they are supplied as a four-element vector of the form c(x0, y0, x1, y1) even if the summary is being produced with spatiality \"y\".\u00a0 To produce the result, a grid with dimensions defined by dims is conceptually stretched out across the given spatial bounds, such that the centers of the edge and corner grid squares are aligned with the limits of the spatial bounds.\u00a0 This matches the way that defineSpatialMap() defines its maps. The particular summary produced depends upon the parameters operation and empty.\u00a0 Consider a single grid square represented by a single element in the result.\u00a0 That grid square contains zero or more of the individuals in individuals.\u00a0 If it contains zero individuals and empty is not NULL, the empty value is used for the result, regardless of operation, providing specific, separate control over the treatment of empty grid squares.\u00a0 If empty is NULL, this separate control over the treatment of empty grid squares is declined; empty grid squares will be handled through the standard mechanism described next.\u00a0 In all other cases for the given grid square \u2013 when it contains more than zero individuals, or when empty is NULL \u2013 operation is executed as an Eidos lambda, a small snippet of code, supplied as a singleton string, that is executed in a manner similar to a function call.\u00a0 Within the execution of the operation lambda, a constant named individuals is defined to be the focal individuals being evaluated \u2013 all of the individuals within that grid square.\u00a0 This lambda should evaluate to a singleton logical, integer, or float value, comprising the result value for the grid square; these types will all be coerced to float (T being 1 and F being 0). Two examples may illustrate the use of empty and operation.\u00a0 To produce a summary indicating presence/absence, simply use the default of 0.0 for empty, and \"1.0; \" (or \"1;\", or \"T;\") for operation.\u00a0 This will produce 0.0 for empty grid squares, and 1.0 for those that contain at least one individual.\u00a0 Note that the use of empty is essential here, because operation doesn\u2019t even check whether individuals are present or not.\u00a0 To produce a summary with a count of the number of individuals in each grid square, again use the default of 0.0 for empty, but now use an operation of \"individuals.size();\", counting the number of individuals in each grid square.\u00a0 In this case, empty could be NULL instead and operation would still produce the correct result; but using empty makes summarizeIndividuals() more efficient since it allows the execution of operation to be skipped for those squares. Lambdas are not limited in their complexity; they can use if, for, etc., and can call methods and functions.\u00a0 A typical operation to compute the mean phenotype in a quantitative genetic model that stores phenotype values in tagF, for example, would be \"mean(individuals.tagF);\", and this is still quite simple compared to what is possible.\u00a0 However, keep in mind that the lambda will be evaluated for every grid cell (or at least those that are non-empty), so efficiency can be a concern, and you may wish to pre-calculate values shared by all of the lambda calls, making them available to your lambda code using defineGlobal() or defineConstant(). There is one last twist, if perUnitArea is T: values are divided by the area (or length, in 1D, or volume, in 3D) that their corresponding grid cell comprises, so that each value is in units of \u201cper unit area\u201d (or \u201cper unit length\u201d, or \u201cper unit volume\u201d).\u00a0 The total area of the grid is defined by the spatial bounds, and the area of a given grid cell is defined by the portion of the spatial bounds that is within that cell.\u00a0 This is not the same for all grid cells; grid cells that fall partially outside spatialBounds (because, remember, the centers of the edge/corner grid cells are aligned with the limits of spatialBounds) will have a smaller area inside the bounds.\u00a0 For an \"xy\" spatiality summary, for example, corner cells have only a quarter of their area inside spatialBounds, while edge elements have half of their area inside spatialBounds; for purposes of perUnitArea, then, their respective areas are \u00bc and \u00bd the area of an interior grid cell.\u00a0 By default, perUnitArea is F, and no scaling is performed.\u00a0 Whether you want perUnitArea to be F or T depends upon whether the summary you are producing is, conceptually, \u201cper unit area\u201d, such as density (individuals per unit area) or local competition strength (total interaction strength per unit area), or is not, such as \u201cmean individual age\u201d, or \u201cmaximum tag value\u201d.\u00a0 For the previous example of counting individuals with an operation of \"individuals.size();\", a value of F for perUnitArea (the default) will produce a simple count of individuals in each grid square, whereas with T it would produce the density of individuals in each grid square."
        },
        "treeSeqMetadata": {
            "signatures": [
                "(object<Dictionary>$)treeSeqMetadata(string$\u00a0filePath, [logical$\u00a0userData\u00a0=\u00a0T])"
            ],
            "description": "Returns a Dictionary containing top-level metadata from the .trees (tree-sequence) file at filePath.\u00a0 If userData is T (the default), the top-level metadata under the SLiM/user_metadata key is returned; this is the same metadata that can optionally be supplied to treeSeqOutput() in its metadata parameter, so it makes it easy to recover metadata that you attached to the tree sequence when it was saved.\u00a0 If userData is F, the entire top-level metadata Dictionary object is returned; this can be useful for examining the values of other keys under the SLiM key, or values inside the top-level dictionary itself that might have been placed there by msprime or other software. This function can be used to read in parameter values or other saved state (tag property values, for example), in order to resuscitate the complete state of a simulation that was written to a .trees file.\u00a0 It could be used for more esoteric purposes too, such as to search through .trees files in a directory (with the help of the Eidos function filesAtPath()) to find those files that satisfy some metadata criterion."
        }
    }
}